<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lunar Lander</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            background: #000;
            overflow: hidden;
            font-family: 'Courier New', monospace;
            color: #0f0;
        }
        #gameContainer {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
        #hud {
            display: none;
        }

        @keyframes blink {
            50% { opacity: 0.5; }
        }

        @keyframes pulse-light {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.4; }
        }

        @keyframes fadeIn {
            to { opacity: 1; }
        }

        /* Cockpit Frame */
        #cockpitFrame {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            height: 140px;
            background: linear-gradient(to bottom,
                transparent 0%,
                rgba(20, 20, 35, 0.8) 10%,
                rgba(15, 15, 25, 0.95) 30%,
                #0a0a15 100%);
            border-top: 3px solid #333;
            display: flex;
            justify-content: center;
            align-items: flex-end;
            padding-bottom: 10px;
            z-index: 50;
        }

        #cockpitFrame::before {
            content: '';
            position: absolute;
            top: -20px;
            left: 0;
            right: 0;
            height: 20px;
            background: linear-gradient(to bottom, transparent, rgba(0,0,0,0.3));
            pointer-events: none;
        }


        /* Main cockpit panel */
        #cockpit {
            display: flex;
            gap: 15px;
            align-items: flex-end;
            padding: 10px 20px;
            background: linear-gradient(145deg, #1a1a2e 0%, #0d0d1a 100%);
            border: 2px solid #444;
            border-bottom: none;
            border-radius: 15px 15px 0 0;
            box-shadow: 0 -5px 30px rgba(0, 255, 0, 0.1), inset 0 0 30px rgba(0, 0, 0, 0.5);
        }

        .cockpit-section {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .cockpit-section-title {
            font-size: 8px;
            color: #555;
            letter-spacing: 2px;
            text-align: center;
            margin-bottom: 2px;
        }

        /* Gauges */
        .gauge {
            min-width: 90px;
        }

        .gauge-label {
            display: flex;
            justify-content: space-between;
            font-size: 9px;
            color: #888;
            margin-bottom: 2px;
        }

        .gauge-value {
            color: #0f0;
            font-weight: bold;
            text-shadow: 0 0 5px #0f0;
            font-size: 11px;
        }

        .gauge-value.warning {
            color: #ff0;
            text-shadow: 0 0 5px #ff0;
        }

        .gauge-value.danger {
            color: #f00;
            text-shadow: 0 0 5px #f00;
            animation: blink 0.5s infinite;
        }

        .gauge-bar {
            height: 10px;
            background: #111;
            border-radius: 5px;
            overflow: hidden;
            border: 1px solid #333;
            display: flex;
            gap: 1px;
            padding: 1px;
        }

        .gauge-segment {
            flex: 1;
            background: #1a1a1a;
            border-radius: 1px;
            transition: background 0.1s;
        }

        .gauge-segment.lit {
            background: #0f0;
            box-shadow: 0 0 3px #0f0;
        }

        .gauge-segment.lit.warning {
            background: #ff0;
            box-shadow: 0 0 3px #ff0;
        }

        .gauge-segment.lit.danger {
            background: #f00;
            box-shadow: 0 0 3px #f00;
        }

        /* Attitude Indicator */
        .attitude-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 3px;
        }

        .attitude-indicator {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            background: #111;
            border: 3px solid #555;
            position: relative;
            overflow: hidden;
            box-shadow: inset 0 0 20px rgba(0,0,0,0.9), 0 0 15px rgba(0,0,0,0.5);
        }

        .attitude-ring {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border-radius: 50%;
            border: 2px solid #333;
            box-sizing: border-box;
        }

        .attitude-ball {
            position: absolute;
            top: 5px;
            left: 5px;
            right: 5px;
            bottom: 5px;
            border-radius: 50%;
            overflow: hidden;
            transition: transform 0.1s;
        }

        .attitude-sky {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 50%;
            background: linear-gradient(to bottom, #0a1a2c 0%, #1a3a5c 100%);
        }

        .attitude-ground {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 50%;
            background: linear-gradient(to bottom, #6a4a2a 0%, #3a2a1a 100%);
        }

        .attitude-horizon-line {
            position: absolute;
            top: 50%;
            left: 0;
            width: 100%;
            height: 2px;
            background: #fff;
            transform: translateY(-50%);
        }

        .attitude-pitch-lines {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 40px;
        }

        .attitude-pitch-lines::before,
        .attitude-pitch-lines::after {
            content: '';
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
            width: 20px;
            height: 1px;
            background: rgba(255,255,255,0.5);
        }

        .attitude-pitch-lines::before { top: -15px; }
        .attitude-pitch-lines::after { top: 15px; }

        .attitude-center-mark {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 10;
            pointer-events: none;
        }

        .attitude-center-mark::before {
            content: '';
            position: absolute;
            top: -1px;
            left: -25px;
            width: 18px;
            height: 3px;
            background: #f80;
            box-shadow: 0 0 5px #f80;
        }

        .attitude-center-mark::after {
            content: '';
            position: absolute;
            top: -1px;
            right: -25px;
            width: 18px;
            height: 3px;
            background: #f80;
            box-shadow: 0 0 5px #f80;
        }

        .attitude-center-dot {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 10px;
            height: 10px;
            background: #f80;
            border-radius: 50%;
            box-shadow: 0 0 8px #f80;
            z-index: 10;
        }

        .attitude-scale {
            position: absolute;
            top: 6px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 8px;
            color: #fff;
        }

        .angle-readout, .velocity-readout {
            font-size: 16px;
            color: #0f0;
            text-shadow: 0 0 5px #0f0;
            font-weight: bold;
            text-align: center;
        }

        .angle-readout.warning, .velocity-readout.warning {
            color: #ff0;
            text-shadow: 0 0 5px #ff0;
        }

        .angle-readout.danger, .velocity-readout.danger {
            color: #f00;
            text-shadow: 0 0 5px #f00;
        }

        /* Velocity Vector Indicator */
        .velocity-indicator {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            background: radial-gradient(circle at 50% 50%, #1a1a2a 0%, #0a0a15 100%);
            border: 3px solid #555;
            position: relative;
            overflow: hidden;
            box-shadow: inset 0 0 20px rgba(0,0,0,0.9), 0 0 15px rgba(0,0,0,0.5);
        }

        .velocity-ring {
            position: absolute;
            top: 5px;
            left: 5px;
            right: 5px;
            bottom: 5px;
            border-radius: 50%;
            border: 1px solid #333;
        }

        .velocity-grid {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        .velocity-grid::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 10%;
            right: 10%;
            height: 1px;
            background: linear-gradient(to right, transparent, #333, #333, transparent);
        }

        .velocity-grid::after {
            content: '';
            position: absolute;
            left: 50%;
            top: 10%;
            bottom: 10%;
            width: 1px;
            background: linear-gradient(to bottom, transparent, #333, #333, transparent);
        }

        .velocity-arrow {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 4px;
            height: 30px;
            background: linear-gradient(to bottom, #0ff, #0aa);
            transform-origin: center top;
            transform: translate(-50%, 0) rotate(0deg);
            border-radius: 2px;
            box-shadow: 0 0 8px #0ff;
            transition: transform 0.1s, height 0.1s;
        }

        .velocity-arrow::after {
            content: '';
            position: absolute;
            bottom: -8px;
            left: 50%;
            transform: translateX(-50%);
            border-left: 6px solid transparent;
            border-right: 6px solid transparent;
            border-top: 10px solid #0f0;
            filter: drop-shadow(0 0 3px #0ff);
        }

        .velocity-arrow.warning {
            background: linear-gradient(to bottom, #ff0, #aa0);
            box-shadow: 0 0 8px #ff0;
        }

        .velocity-arrow.warning::after {
            border-top-color: #ff0;
            filter: drop-shadow(0 0 3px #ff0);
        }

        .velocity-arrow.danger {
            background: linear-gradient(to bottom, #f00, #f00);
            box-shadow: 0 0 8px #f00;
        }

        .velocity-arrow.danger::after {
            border-top-color: #f00;
            filter: drop-shadow(0 0 3px #f00);
        }

        .velocity-center {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 10px;
            height: 10px;
            background: #0ff;
            border-radius: 50%;
            box-shadow: 0 0 8px #0ff;
            z-index: 5;
        }

        .velocity-labels {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            font-size: 7px;
            color: #555;
        }

        .velocity-labels span {
            position: absolute;
        }

        .velocity-labels .v-up { top: 6px; left: 50%; transform: translateX(-50%); }
        .velocity-labels .v-down { bottom: 6px; left: 50%; transform: translateX(-50%); }
        .velocity-labels .v-left { left: 6px; top: 50%; transform: translateY(-50%); }
        .velocity-labels .v-right { right: 6px; top: 50%; transform: translateY(-50%); }

        /* Status Lights Panel */
        .status-lights {
            display: flex;
            flex-direction: column;
            gap: 5px;
            padding: 5px;
        }

        .status-light {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .status-light .light {
            width: 14px;
            height: 14px;
            border-radius: 50%;
            border: 1px solid #444;
        }

        .status-light .label {
            font-size: 9px;
            color: #888;
        }

        .status-light .light.green {
            background: radial-gradient(circle at 30% 30%, #4f4, #0f0);
            box-shadow: 0 0 10px #0f0;
        }

        .status-light .light.yellow {
            background: radial-gradient(circle at 30% 30%, #ff8, #ff0);
            box-shadow: 0 0 10px #ff0;
        }

        .status-light .light.red {
            background: radial-gradient(circle at 30% 30%, #f44, #f00);
            box-shadow: 0 0 10px #f00;
            animation: blink 0.3s infinite;
        }

        .status-light .light.off {
            background: radial-gradient(circle at 30% 30%, #444, #222);
            box-shadow: none;
        }

        /* Mission Control Radio */
        #missionControl {
            min-width: 220px;
            max-width: 280px;
            background: linear-gradient(145deg, #12121f 0%, #0a0a12 100%);
            border: 2px solid #333;
            border-radius: 8px;
            padding: 8px;
            box-shadow: inset 0 0 20px rgba(0, 0, 0, 0.5);
        }

        .radio-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 5px;
            padding-bottom: 4px;
            border-bottom: 1px solid #333;
        }

        .radio-title {
            font-size: 9px;
            color: #666;
            letter-spacing: 2px;
        }

        .radio-status {
            display: flex;
            align-items: center;
            gap: 4px;
            font-size: 8px;
            color: #0a0;
        }

        .radio-light {
            width: 6px;
            height: 6px;
            background: #0f0;
            border-radius: 50%;
            box-shadow: 0 0 5px #0f0;
            animation: pulse-light 2s infinite;
        }

        #radioMessages {
            height: 70px;
            overflow: hidden;
            font-size: 10px;
            line-height: 1.4;
        }

        .radio-message {
            margin-bottom: 3px;
            opacity: 0;
            animation: fadeIn 0.3s forwards;
        }

        .radio-message .timestamp {
            color: #444;
            margin-right: 4px;
        }

        .radio-message .callsign {
            color: #0af;
            font-weight: bold;
        }

        .radio-message .text {
            color: #0f0;
        }

        .radio-message.warning .text {
            color: #ff0;
        }

        .radio-message.danger .text {
            color: #f00;
        }

        .radio-message.success .text {
            color: #0f0;
            text-shadow: 0 0 5px #0f0;
        }

        /* Mobile adjustments */
        .mobile #cockpitFrame {
            height: auto;
            background: transparent;
            border: none;
        }

        .mobile #cockpitFrame::before {
            display: none;
        }

        .mobile #cockpit {
            gap: 6px;
            padding: 8px 10px;
            border-radius: 10px;
            border: 2px solid #444;
        }

        .mobile #missionControl {
            display: none;
        }

        .mobile .cockpit-section-title {
            display: none;
        }

        .mobile .attitude-indicator,
        .mobile .velocity-indicator {
            width: 55px;
            height: 55px;
        }

        .mobile .velocity-arrow {
            height: 18px;
        }

        .mobile .angle-readout,
        .mobile .velocity-readout {
            font-size: 12px;
        }

        .mobile .gauge {
            min-width: 60px;
        }

        .mobile .gauge-label {
            font-size: 8px;
        }

        .mobile .gauge-value {
            font-size: 10px;
        }

        .mobile .status-lights {
            gap: 3px;
        }

        .mobile .status-light .light {
            width: 10px;
            height: 10px;
        }

        .mobile .status-light .label {
            font-size: 7px;
        }
        #message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 24px;
            text-align: center;
            display: none;
            text-shadow: 0 0 10px currentColor;
        }
        #instructions {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 12px;
            text-align: center;
            opacity: 0.7;
            z-index: 10;
        }

        /* Mobile controls - two-handed layout */
        #mobileControls {
            display: none;
            position: fixed;
            bottom: 145px;
            left: 0;
            right: 0;
            padding: 15px;
            pointer-events: none;
            justify-content: space-between;
            z-index: 60;
        }

        #leftControls {
            display: flex;
            gap: 10px;
            pointer-events: auto;
        }

        #rightControls {
            display: flex;
            pointer-events: auto;
        }

        #thrustButton {
            width: 120px;
            height: 100px;
            background: radial-gradient(circle at center, rgba(255, 100, 0, 0.5) 0%, rgba(255, 50, 0, 0.25) 70%, transparent 100%);
            border: 3px solid rgba(255, 150, 0, 0.7);
            border-radius: 15px;
            color: #f80;
            font-size: 14px;
            font-family: 'Courier New', monospace;
            font-weight: bold;
            text-shadow: 0 0 10px #f80;
            cursor: pointer;
            touch-action: none;
            user-select: none;
            -webkit-user-select: none;
            transition: all 0.1s;
            line-height: 1.3;
        }

        #thrustButton:active, #thrustButton.active {
            background: radial-gradient(circle at center, rgba(255, 150, 0, 0.8) 0%, rgba(255, 100, 0, 0.5) 70%, transparent 100%);
            border-color: rgba(255, 200, 0, 1);
            transform: scale(0.97);
        }

        .rotateBtn {
            width: 80px;
            height: 100px;
            background: radial-gradient(circle at center, rgba(0, 150, 255, 0.4) 0%, rgba(0, 100, 200, 0.2) 70%, transparent 100%);
            border: 3px solid rgba(0, 150, 255, 0.6);
            border-radius: 15px;
            color: #0af;
            font-size: 32px;
            font-family: 'Courier New', monospace;
            font-weight: bold;
            text-shadow: 0 0 10px #0af;
            cursor: pointer;
            touch-action: none;
            user-select: none;
            -webkit-user-select: none;
            transition: all 0.1s;
        }

        .rotateBtn:active, .rotateBtn.active {
            background: radial-gradient(circle at center, rgba(0, 200, 255, 0.6) 0%, rgba(0, 150, 255, 0.4) 70%, transparent 100%);
            border-color: rgba(0, 200, 255, 0.9);
            transform: scale(0.97);
        }

        /* Landscape mode adjustments */
        @media (orientation: landscape) and (max-height: 500px) {
            #mobileControls {
                bottom: 95px;
                padding: 8px 15px;
            }
            #thrustButton, .rotateBtn {
                height: 55px;
            }
            #thrustButton {
                width: 85px;
                font-size: 10px;
            }
            .rotateBtn {
                width: 55px;
                font-size: 20px;
            }
            .mobile #cockpit {
                gap: 4px;
                padding: 5px 8px;
            }
            .mobile .attitude-indicator,
            .mobile .velocity-indicator {
                width: 45px;
                height: 45px;
            }
            .mobile .angle-readout,
            .mobile .velocity-readout {
                font-size: 10px;
            }
            .mobile .gauge {
                min-width: 50px;
            }
            .mobile .gauge-bar {
                height: 6px;
            }
        }

        /* Hide rotation buttons when gyro is working */
        .gyro-active #leftControls {
            display: none;
        }

        #gyroPrompt {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.9);
            z-index: 1000;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            color: #0f0;
            font-size: 18px;
            text-align: center;
            padding: 30px;
        }

        #gyroPrompt button {
            margin-top: 30px;
            padding: 15px 40px;
            font-size: 20px;
            background: #0a0;
            border: none;
            border-radius: 10px;
            color: white;
            font-family: 'Courier New', monospace;
            cursor: pointer;
        }


        .mobile #instructions {
            display: none;
        }

        .mobile #hud {
            font-size: 12px;
            top: 5px;
            left: 5px;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="game"></canvas>
        <div id="hud">
            <div>FUEL: <span id="fuel">100</span>%</div>
            <div>ALTITUDE: <span id="altitude">0</span>m</div>
            <div>HORIZONTAL: <span id="hSpeed">0</span>m/s</div>
            <div>VERTICAL: <span id="vSpeed">0</span>m/s</div>
        </div>

        <!-- Bottom Cockpit Frame -->
        <div id="cockpitFrame">
            <div id="cockpit">
                <!-- Status Lights -->
                <div class="cockpit-section">
                    <div class="cockpit-section-title">STATUS</div>
                    <div class="status-lights">
                        <div class="status-light">
                            <div class="light green" id="lightAlt"></div>
                            <div class="label">ALT</div>
                        </div>
                        <div class="status-light">
                            <div class="light green" id="lightVel"></div>
                            <div class="label">VEL</div>
                        </div>
                        <div class="status-light">
                            <div class="light green" id="lightFuel"></div>
                            <div class="label">FUEL</div>
                        </div>
                        <div class="status-light">
                            <div class="light off" id="lightWarn"></div>
                            <div class="label">WARN</div>
                        </div>
                    </div>
                </div>

                <!-- Gauges Left -->
                <div class="cockpit-section">
                    <div class="gauge">
                        <div class="gauge-label">
                            <span>ALT</span>
                            <span class="gauge-value" id="altValue">0m</span>
                        </div>
                        <div class="gauge-bar" id="altBar"></div>
                    </div>
                    <div class="gauge">
                        <div class="gauge-label">
                            <span>FUEL</span>
                            <span class="gauge-value" id="fuelValue">100%</span>
                        </div>
                        <div class="gauge-bar" id="fuelBar"></div>
                    </div>
                </div>

                <!-- Attitude Indicator -->
                <div class="cockpit-section">
                    <div class="cockpit-section-title">ATTITUDE</div>
                    <div class="attitude-container">
                        <div class="attitude-indicator">
                            <div class="attitude-ring"></div>
                            <div class="attitude-ball" id="attitudeBall">
                                <div class="attitude-sky"></div>
                                <div class="attitude-ground"></div>
                                <div class="attitude-horizon-line"></div>
                                <div class="attitude-pitch-lines"></div>
                            </div>
                            <div class="attitude-center-mark"></div>
                            <div class="attitude-center-dot"></div>
                            <div class="attitude-scale">â–²</div>
                        </div>
                        <div class="angle-readout" id="angleReadout">0Â°</div>
                    </div>
                </div>

                <!-- Velocity Vector Indicator -->
                <div class="cockpit-section">
                    <div class="cockpit-section-title">VELOCITY</div>
                    <div class="attitude-container">
                        <div class="velocity-indicator">
                            <div class="velocity-ring"></div>
                            <div class="velocity-grid"></div>
                            <div class="velocity-labels">
                                <span class="v-up">â–²</span>
                                <span class="v-down">â–¼</span>
                                <span class="v-left">â—€</span>
                                <span class="v-right">â–¶</span>
                            </div>
                            <div class="velocity-arrow" id="velocityArrow"></div>
                            <div class="velocity-center"></div>
                        </div>
                        <div class="velocity-readout" id="velocityReadout">0</div>
                    </div>
                </div>

                <!-- Gauges Right -->
                <div class="cockpit-section">
                    <div class="gauge">
                        <div class="gauge-label">
                            <span>V/S</span>
                            <span class="gauge-value" id="vSpeedValue">0</span>
                        </div>
                        <div class="gauge-bar" id="vSpeedBar"></div>
                    </div>
                    <div class="gauge">
                        <div class="gauge-label">
                            <span>H/S</span>
                            <span class="gauge-value" id="hSpeedValue">0</span>
                        </div>
                        <div class="gauge-bar" id="hSpeedBar"></div>
                    </div>
                </div>

                <!-- Mission Control Radio -->
                <div id="missionControl">
                    <div class="radio-header">
                        <span class="radio-title">â—† CAPCOM â—†</span>
                        <span class="radio-status">
                            <span class="radio-light"></span>
                            LINK
                        </span>
                    </div>
                    <div id="radioMessages"></div>
                </div>
            </div>
        </div>
        <div id="message"></div>
        <div id="instructions">
            ARROW KEYS or WASD to control | SPACE for thrust | R to restart
        </div>

        <!-- Mobile controls - two-handed layout -->
        <div id="mobileControls">
            <!-- Left side: rotation controls -->
            <div id="leftControls">
                <button id="rotateLeftBtn" class="rotateBtn">â—€</button>
                <button id="rotateRightBtn" class="rotateBtn">â–¶</button>
            </div>
            <!-- Right side: thrust -->
            <div id="rightControls">
                <button id="thrustButton">ðŸ”¥<br>THRUST</button>
            </div>
        </div>


        <!-- Gyroscope permission prompt (required on iOS) -->
        <div id="gyroPrompt">
            <p>This game uses your device's tilt sensor to control the spaceship.</p>
            <p style="margin-top: 15px; opacity: 0.8;">Tilt left/right to rotate<br>Press the button to thrust</p>
            <button id="enableGyro">Enable Controls</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('game');
        const ctx = canvas.getContext('2d');

        // Set canvas size to full screen
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        resizeCanvas();

        // Handle window resize
        window.addEventListener('resize', () => {
            resizeCanvas();
            generateTerrain();
            // Regenerate stars for new canvas size
            stars = [];
            for (let i = 0; i < 150; i++) {
                stars.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height * 0.7,
                    size: Math.random() * 2 + 0.5,
                    brightness: Math.random()
                });
            }
        });

        // Load spaceship image and make black background transparent
        const shipImg = new Image();
        const shipImgTransparent = document.createElement('canvas');
        let shipImgReady = false;

        shipImg.onload = function() {
            // Create a canvas to process the image
            shipImgTransparent.width = shipImg.width;
            shipImgTransparent.height = shipImg.height;
            const imgCtx = shipImgTransparent.getContext('2d');
            imgCtx.drawImage(shipImg, 0, 0);

            // Get image data and make black pixels transparent
            const imageData = imgCtx.getImageData(0, 0, shipImg.width, shipImg.height);
            const data = imageData.data;

            for (let i = 0; i < data.length; i += 4) {
                // Check if pixel is black or very dark (threshold of 30)
                if (data[i] < 30 && data[i + 1] < 30 && data[i + 2] < 30) {
                    data[i + 3] = 0; // Set alpha to 0 (transparent)
                }
            }

            imgCtx.putImageData(imageData, 0, 0);
            shipImgReady = true;
        };

        shipImg.src = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEgAAAA7CAYAAADYW8woAAAACXBIWXMAAA7EAAAOxAGVKw4bAAACSElEQVR4Xu2ZO5LCMBBE21t7LAg4GAT4YARwL28AY8TsSC0byRD0i/DYiCrpufVhADBBZPnxBfGKOoigDiL8+sIWnM9nAMDhcAAA7Ha79DYAYBzHl2t7dr/fv9R7I4MI3Q26Xq++NBtzu93cnTyXywXAs72tTJJBhG4G2UjbyKf4WpRBObxJQF+bZBBBHUQY0HirMU335vw0DQCn4/G1MAwAnt9JGR734O6dH+2eTqe51jO4ZRChW0gb6UjDPgfGUB5GWWu22EzpYZIMInQ3KMTypYbMs1EG9UAGEbobFM1QtsWwRV8040UZw2iZPYYMIqiDCN1fsQh7tWrOeHKvmkL6S+hmkI2wWQLkd+2RASWrtkQGEZoZ5Kdzu543nYhNWYqZGbWlrcYHaGZQjtQssyk3M6X4E8mSOUZLcwwZRGh+YGZEeeBr/jrCG+O/m9Z6IIMI6iDCW69YsFFfhf1/mK4jfS13XaLFmyeDCKumeTMnPexbY5O3ImrPP7PEnDTf19okgwirDGqFWTGO94XjND2PMPzfYmtMaoEMIiwyKMqedzBzjse7OVEG5UyqIc0dy6OlWSSDCIsMaoU3J7LCai1MegcZRFAHEaq2GjWLwCXB7V8bXwfy93w9onBkNFMb1jKIsCika0avBh+4pXZrnvGU7KixK0UGEYoZtGb01lDKuF6/XbtwlEGERRnUC59Jae3TyCCCOojwL6Q/qfknfpuFtQwiqIMI6iDCnEGlxZrROxe2yKCarUaaRzKI8G8W25JvsJYhgwh/c+Hrbq9qJiwAAAAASUVORK5CYII=';

        // Game constants
        const GRAVITY = 0.02;
        const THRUST = 0.05;
        const ROTATION_SPEED = 0.05;
        const MAX_LANDING_SPEED = 1.5;
        const MAX_LANDING_ANGLE = 0.3;
        const FUEL_CONSUMPTION = 0.2;

        // Game state
        let ship = {};
        let terrain = [];
        let landingPad = {};
        let gameState = 'playing'; // 'playing', 'landed', 'crashed', 'contacting'
        let stars = [];

        // Input state
        const keys = {};

        // Cockpit System
        const GAUGE_SEGMENTS = 12;
        const cockpitElements = {
            altValue: document.getElementById('altValue'),
            altBar: document.getElementById('altBar'),
            vSpeedValue: document.getElementById('vSpeedValue'),
            vSpeedBar: document.getElementById('vSpeedBar'),
            hSpeedValue: document.getElementById('hSpeedValue'),
            hSpeedBar: document.getElementById('hSpeedBar'),
            fuelValue: document.getElementById('fuelValue'),
            fuelBar: document.getElementById('fuelBar'),
            attitudeBall: document.getElementById('attitudeBall'),
            angleReadout: document.getElementById('angleReadout'),
            velocityArrow: document.getElementById('velocityArrow'),
            velocityReadout: document.getElementById('velocityReadout'),
            lightAlt: document.getElementById('lightAlt'),
            lightVel: document.getElementById('lightVel'),
            lightFuel: document.getElementById('lightFuel'),
            lightWarn: document.getElementById('lightWarn'),
            radioMessages: document.getElementById('radioMessages')
        };

        // Initialize gauge bars
        function initGaugeBars() {
            [cockpitElements.altBar, cockpitElements.vSpeedBar,
             cockpitElements.hSpeedBar, cockpitElements.fuelBar].forEach(bar => {
                bar.innerHTML = '';
                for (let i = 0; i < GAUGE_SEGMENTS; i++) {
                    const seg = document.createElement('div');
                    seg.className = 'gauge-segment';
                    bar.appendChild(seg);
                }
            });
        }

        function updateGaugeBar(bar, valueEl, value, max, unit = '', thresholds = null, showSign = false) {
            const segments = bar.children;
            const absValue = Math.abs(value);
            const normalizedValue = Math.min(1, Math.max(0, absValue / max));
            const litCount = Math.round(normalizedValue * GAUGE_SEGMENTS);

            let colorClass = '';

            if (thresholds) {
                const { warning, danger, type } = thresholds;

                // Use 'low' type for things like fuel or altitude (lower is worse)
                // Use 'high' (default) for things like speed or heat (higher is worse)
                if (type === 'low') {
                    if (value <= danger) colorClass = 'danger';
                        else if (value <= warning) colorClass = 'warning';
                } else {
                    if (value >= danger) colorClass = 'danger';
                        else if (value >= warning) colorClass = 'warning';
                }
            }

            // Update Segments
            for (let i = 0; i < segments.length; i++) {
                segments[i].className = 'gauge-segment';
                if (i < litCount) {
                    segments[i].classList.add('lit');
                    if (colorClass) segments[i].classList.add(colorClass);
                }
            }

            // Update Text
            const formattedNum = value.toFixed(1);
            const displayValue = showSign && value > 0 ? `+${formattedNum}` : formattedNum;

            valueEl.textContent = displayValue + unit;
            valueEl.className = 'gauge-value';
            if (colorClass) valueEl.classList.add(colorClass);
        }

        function updateStatusLight(light, status) {
            light.className = 'light ' + status;
        }

        function updateCockpit() {
            const SAFE_SPEED_TOTAL = CRASH_VELOCITY * 10;
            const SAFE_SPEED_1AXIS = SAFE_SPEED_TOTAL / 2;
            const altitude = Math.max(0, getAltitude());
            const vSpeed = ship.vy * 10;
            const hSpeed = ship.vx * 10;
            const fuel = ship.fuel;
            const totalSpeed = Math.sqrt(vSpeed * vSpeed + hSpeed * hSpeed);

            // Update gauges
            updateGaugeBar(cockpitElements.altBar, cockpitElements.altValue, altitude, 500, 'm', {danger: 50, warning: 100, type: 'low'});
            updateGaugeBar(cockpitElements.vSpeedBar, cockpitElements.vSpeedValue, vSpeed, 40, '', {danger: SAFE_SPEED_1AXIS, warning: SAFE_SPEED_1AXIS*10, type: 'high'}, true);
            updateGaugeBar(cockpitElements.hSpeedBar, cockpitElements.hSpeedValue, hSpeed, 40, '', {danger: SAFE_SPEED_1AXIS, warning: SAFE_SPEED_1AXIS*10, type: 'high'}, true);
            updateGaugeBar(cockpitElements.fuelBar, cockpitElements.fuelValue, fuel, 100, '%', {danger: 20, warning: 50, type: 'low'}, 'inverted');

            // Update attitude indicator - rotate the ball with ship angle
            const angleDeg = ship.angle * (180 / Math.PI);
            cockpitElements.attitudeBall.style.transform = `rotate(${angleDeg}deg)`;

            // Update angle readout
            const absAngle = Math.abs(angleDeg);
            cockpitElements.angleReadout.textContent = (angleDeg >= 0 ? '+' : '') + angleDeg.toFixed(0) + 'Â°';
            cockpitElements.angleReadout.className = 'angle-readout';
            if (absAngle > 30) cockpitElements.angleReadout.classList.add('danger');
            else if (absAngle > 15) cockpitElements.angleReadout.classList.add('warning');

            // Update velocity vector indicator
            // Calculate direction: atan2 gives angle from positive X axis, we want from top (negative Y)
            // So we use atan2(vx, vy) to get angle from vertical
            const velAngle = Math.atan2(hSpeed, vSpeed) * (180 / Math.PI);
            // Arrow length based on speed (min 5px, max 30px)
            const arrowLength = Math.min(30, Math.max(5, totalSpeed * 1.5));

            cockpitElements.velocityArrow.style.transform = `translate(-50%, 0) rotate(${-velAngle}deg)`;
            cockpitElements.velocityArrow.style.height = arrowLength + 'px';

            // Color based on speed
            cockpitElements.velocityArrow.className = 'velocity-arrow';
            if (totalSpeed > 25) cockpitElements.velocityArrow.classList.add('danger');
            else if (totalSpeed > SAFE_SPEED_TOTAL) cockpitElements.velocityArrow.classList.add('warning');

            // Update velocity readout
            cockpitElements.velocityReadout.textContent = totalSpeed.toFixed(1);
            cockpitElements.velocityReadout.className = 'velocity-readout';
            if (totalSpeed > 25) cockpitElements.velocityReadout.classList.add('danger');
            else if (totalSpeed > SAFE_SPEED_TOTAL) cockpitElements.velocityReadout.classList.add('warning');

            // Update status lights
            updateStatusLight(cockpitElements.lightAlt, altitude < 50 ? (altitude < 20 ? 'red' : 'yellow') : 'green');
            // VEL is green only when within safe landing limits
            updateStatusLight(cockpitElements.lightVel, totalSpeed > 25 ? 'red' : (totalSpeed > SAFE_SPEED_TOTAL ? 'yellow' : 'green'));
            updateStatusLight(cockpitElements.lightFuel, fuel < 20 ? 'red' : (fuel < 40 ? 'yellow' : 'green'));

            // Warning light - on if any condition is dangerous for landing
            const danger = altitude < 20 || totalSpeed > SAFE_SPEED_TOTAL || fuel < 20 || absAngle > 17;
            updateStatusLight(cockpitElements.lightWarn, danger ? 'red' : 'off');
        }

        // Mission Control Radio System
        const radioCallsigns = ['CAPCOM', 'HOUSTON', 'FLIGHT', 'FIDO', 'GUIDO'];
        let lastRadioTime = 0;
        let lastRadioCondition = '';

        const radioMessages = {
            start: [
                "Eagle, you are GO for powered descent.",
                "Telemetry looks good. Begin approach.",
                "All systems nominal. You're cleared for landing.",
                "Altitude check... looking good Eagle."
            ],
            highAlt: [
                "Altitude {alt}m. Continue descent.",
                "Looking good at {alt} meters.",
                "Descent rate nominal."
            ],
            medAlt: [
                "Passing {alt} meters. Watch your speed.",
                "You're coming in nicely.",
                "Throttle up if needed."
            ],
            lowAlt: [
                "Contact light should be soon.",
                "30 seconds of fuel remaining.",
                "Almost there, Eagle.",
                "Looking good for touchdown."
            ],
            dangerAlt: [
                "ALTITUDE! Pull up!",
                "Too low! Increase thrust!",
                "TERRAIN WARNING!"
            ],
            fastDescent: [
                "Descent rate high! Slow down!",
                "You're coming in too fast!",
                "Vertical speed excessive!"
            ],
            goodDescent: [
                "Descent rate good.",
                "Speed looks nominal.",
                "Nice and easy..."
            ],
            lowFuel: [
                "FUEL WARNING! Bingo fuel!",
                "Low fuel! Land immediately!",
                "Fuel critical!"
            ],
            drifting: [
                "Watch your horizontal drift.",
                "Correct lateral movement.",
                "Drifting off target."
            ],
            idle: [
                "Eagle, Houston. Radio check.",
                "How's it looking up there?",
                "Steady as she goes.",
                "All stations, this is FLIGHT.",
                "Telemetry nominal."
            ],
            landed: [
                "TOUCHDOWN! The Eagle has landed!",
                "Houston, Tranquility Base here.",
                "Mission success! Well done!",
                "Copy, Eagle. Beautiful landing!"
            ],
            crashed: [
                "We've lost signal...",
                "EAGLE! EAGLE, respond!",
                "Flight, we have a problem..."
            ]
        };

        function getRandomMessage(category) {
            const msgs = radioMessages[category];
            return msgs[Math.floor(Math.random() * msgs.length)];
        }

        function addRadioMessage(text, type = '') {
            const msg = document.createElement('div');
            msg.className = 'radio-message' + (type ? ' ' + type : '');

            const time = new Date();
            const timestamp = time.getMinutes().toString().padStart(2, '0') + ':' +
                            time.getSeconds().toString().padStart(2, '0');
            const callsign = radioCallsigns[Math.floor(Math.random() * radioCallsigns.length)];

            // Replace placeholders
            text = text.replace('{alt}', Math.floor(getAltitude()));
            text = text.replace('{fuel}', Math.floor(ship.fuel));

            msg.innerHTML = `<span class="timestamp">${timestamp}</span><span class="callsign">${callsign}:</span> <span class="text">${text}</span>`;

            cockpitElements.radioMessages.insertBefore(msg, cockpitElements.radioMessages.firstChild);

            // Keep only last 6 messages
            while (cockpitElements.radioMessages.children.length > 6) {
                cockpitElements.radioMessages.removeChild(cockpitElements.radioMessages.lastChild);
            }
        }

        function updateRadio() {
            if (gameState !== 'playing') return;

            const now = Date.now();
            const timeSinceLastRadio = now - lastRadioTime;

            const altitude = getAltitude();
            const vSpeed = ship.vy * 10;
            const hSpeed = Math.abs(ship.vx * 10);
            const fuel = ship.fuel;

            let condition = '';
            let type = '';
            let minDelay = 3000;

            // Priority conditions
            if (altitude < 30 && vSpeed > 12) {
                condition = 'dangerAlt';
                type = 'danger';
                minDelay = 2000;
            } else if (fuel < 20) {
                condition = 'lowFuel';
                type = 'danger';
                minDelay = 2500;
            } else if (vSpeed > 15) {
                condition = 'fastDescent';
                type = 'warning';
                minDelay = 2500;
            } else if (hSpeed > 8) {
                condition = 'drifting';
                type = 'warning';
                minDelay = 3000;
            } else if (altitude < 50) {
                condition = 'lowAlt';
                minDelay = 3500;
            } else if (altitude < 150) {
                condition = 'medAlt';
                minDelay = 4000;
            } else if (altitude < 400) {
                condition = 'highAlt';
                minDelay = 5000;
            } else {
                condition = 'idle';
                minDelay = 6000;
            }

            // Send message if enough time passed and condition changed or it's been a while
            if (timeSinceLastRadio > minDelay && (condition !== lastRadioCondition || timeSinceLastRadio > 8000)) {
                addRadioMessage(getRandomMessage(condition), type);
                lastRadioTime = now;
                lastRadioCondition = condition;
            }
        }

        function radioGameEnd(success) {
            const category = success ? 'landed' : 'crashed';
            const type = success ? 'success' : 'danger';
            addRadioMessage(getRandomMessage(category), type);
        }

        // Initialize cockpit
        initGaugeBars();

        // Initialize game
        function init() {
            // Reset ship - randomize position and direction
            const startFromLeft = Math.random() > 0.5;
            ship = {
                x: startFromLeft
                    ? 100 + Math.random() * (canvas.width * 0.3)
                    : canvas.width - 100 - Math.random() * (canvas.width * 0.3),
                y: 80,
                vx: (1.0 + Math.random() * 1.0) * (startFromLeft ? 1 : -1),
                vy: 0,
                angle: 0,
                angularVel: 0,  // Angular velocity for physics
                width: 40,
                height: 44,
                fuel: 100,
                thrusting: false,
                visible: true,
                // Physics properties for contact
                contactTime: 0,
                fireActive: false
            };

            // Reset explosion/fire particles
            explosionParticles = [];
            fireParticles = [];

            // Generate terrain
            generateTerrain();

            // Generate stars (more stars for larger screen)
            stars = [];
            const starCount = Math.floor((canvas.width * canvas.height) / 5000);
            for (let i = 0; i < starCount; i++) {
                stars.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height * 0.7,
                    size: Math.random() * 2 + 0.5,
                    brightness: Math.random()
                });
            }

            gameState = 'playing';
            document.getElementById('message').style.display = 'none';

            // Reset radio
            cockpitElements.radioMessages.innerHTML = '';
            lastRadioTime = Date.now();
            lastRadioCondition = '';
            addRadioMessage(getRandomMessage('start'));
        }

        function generateTerrain() {
            terrain = [];
            // More segments for wider screens
            const segments = Math.max(60, Math.floor(canvas.width / 15));
            const segmentWidth = canvas.width / segments;

            // Detect mobile landscape mode
            const isMobileLandscape = isMobile && canvas.width > canvas.height;

            // Landing pad must be at least 1.2x ship width
            const minPadWidth = ship.width * 1.2;
            const padWidthSegments = Math.max(4, Math.ceil(minPadWidth / segmentWidth));

            // Pick a random spot for landing pad (not too close to edges)
            const padSegment = Math.floor(8 + Math.random() * (segments - 16 - padWidthSegments));
            const padWidth = padWidthSegments;

            // Generate some random "mountain" peaks - smaller in mobile landscape
            const numMountains = isMobileLandscape ? (2 + Math.floor(Math.random() * 3)) : (3 + Math.floor(Math.random() * 4));
            const mountains = [];
            for (let m = 0; m < numMountains; m++) {
                mountains.push({
                    center: Math.floor(Math.random() * segments),
                    height: isMobileLandscape ? (30 + Math.random() * 50) : (80 + Math.random() * 150),
                    width: 5 + Math.random() * 10
                });
            }

            // Start at a random height - lower terrain in mobile landscape
            let baseY = isMobileLandscape
                ? canvas.height - 40 - Math.random() * 30
                : canvas.height - 150 - Math.random() * 100;
            let y = baseY;

            // Terrain bounds - much lower in mobile landscape
            const minTerrainY = isMobileLandscape ? canvas.height - 120 : canvas.height - 400;
            const maxTerrainY = canvas.height - 30;

            for (let i = 0; i <= segments; i++) {
                // Create flat landing pad area
                if (i >= padSegment && i <= padSegment + padWidth) {
                    if (i === padSegment) {
                        // Make sure landing pad is in a reasonable spot
                        y = Math.min(y, maxTerrainY - 20);
                        y = Math.max(y, minTerrainY + 20);
                        landingPad = {
                            x: i * segmentWidth,
                            y: y,
                            width: padWidth * segmentWidth
                        };
                    }
                    terrain.push({ x: i * segmentWidth, y: y });
                } else {
                    // Add mountain influence
                    let mountainInfluence = 0;
                    for (const mt of mountains) {
                        const dist = Math.abs(i - mt.center);
                        if (dist < mt.width) {
                            // Smooth mountain shape using cosine
                            mountainInfluence += mt.height * (1 + Math.cos(Math.PI * dist / mt.width)) / 2;
                        }
                    }

                    // Random terrain with varying roughness - less rough in mobile landscape
                    const roughness = isMobileLandscape ? (10 + Math.random() * 20) : (25 + Math.random() * 35);
                    y += (Math.random() - 0.5) * roughness;

                    // Apply mountain influence (mountains go UP, so subtract from y)
                    const targetY = baseY - mountainInfluence;
                    y = y * 0.7 + targetY * 0.3; // Blend toward mountain shape

                    // Keep within bounds
                    y = Math.max(minTerrainY, Math.min(maxTerrainY, y));
                    terrain.push({ x: i * segmentWidth, y: y });
                }
            }
        }

        function update() {
            // Always update explosion/fire effects
            updateExplosion();

            if (gameState === 'contacting') {
                updateContactPhysics();
                return;
            }

            if (gameState !== 'playing') return;

            // Apply gravity
            ship.vy += GRAVITY;

            // Handle input
            ship.thrusting = false;

            if ((keys['ArrowUp'] || keys['KeyW'] || keys['Space']) && ship.fuel > 0) {
                ship.vx += Math.sin(ship.angle) * THRUST;
                ship.vy -= Math.cos(ship.angle) * THRUST;
                ship.fuel -= FUEL_CONSUMPTION;
                ship.thrusting = true;
            }

            if (keys['ArrowLeft'] || keys['KeyA']) {
                ship.angle -= ROTATION_SPEED;
            }

            if (keys['ArrowRight'] || keys['KeyD']) {
                ship.angle += ROTATION_SPEED;
            }

            // Update position
            ship.x += ship.vx;
            ship.y += ship.vy;

            // Check if ship left the screen - loss of communication
            if (ship.x < -ship.width || ship.x > canvas.width + ship.width || ship.y < -ship.height) {
                gameState = 'lost';
                ship.visible = false;
                showMessage('MISSION FAILED!\nSpaceship lost contact\nwith Mission Control!', '#f80');
                return;
            }

            // Check collision with terrain
            checkCollision();

            // Update HUD
            document.getElementById('fuel').textContent = Math.max(0, Math.floor(ship.fuel));
            document.getElementById('altitude').textContent = Math.max(0, Math.floor(getAltitude()));
            document.getElementById('hSpeed').textContent = (ship.vx * 10).toFixed(1);
            document.getElementById('vSpeed').textContent = (ship.vy * 10).toFixed(1);

            // Update cockpit and radio
            updateCockpit();
            updateRadio();
        }

        function getAltitude() {
            // Find terrain height below ship
            for (let i = 0; i < terrain.length - 1; i++) {
                if (terrain[i].x <= ship.x && terrain[i + 1].x > ship.x) {
                    const t = (ship.x - terrain[i].x) / (terrain[i + 1].x - terrain[i].x);
                    const groundY = terrain[i].y + t * (terrain[i + 1].y - terrain[i].y);
                    return groundY - ship.y - ship.height / 2;
                }
            }
            return canvas.height - ship.y;
        }

        function checkCollision() {
            // Use actual ship corners for collision - not bounding box
            const corners = getShipCorners();

            // Check if any corner touches the ground
            for (const corner of corners) {
                const groundY = getGroundYAt(corner.x);
                if (corner.y >= groundY) {
                    // Actual contact - start physics simulation
                    // Same behavior for landing pad and terrain
                    startContactPhysics(groundY);
                    return;
                }
            }

        }

        // Physics constants - heavy spacecraft
        const CRASH_VELOCITY = 1.2;        // Velocity for immediate explosion (displayed as 12 m/s)
        const GROUND_FRICTION_COEF = 0.4;  // Friction coefficient (Î¼)
        const MOMENT_OF_INERTIA = 5000;    // Heavy ship resists rotation
        const STRUCTURAL_LIMIT = 1.5;      // Impact force that damages the ship

        // Explosion/fire particles
        let explosionParticles = [];
        let fireParticles = [];

        // Ship corner positions relative to center (for collision detection)
        function getShipCorners() {
            const cos = Math.cos(ship.angle);
            const sin = Math.sin(ship.angle);

            // Define ship shape: body corners and leg feet
            const localPoints = [
                { x: -10, y: -18, name: 'bodyLeft', isBody: true },
                { x: 10, y: -18, name: 'bodyRight', isBody: true },
                { x: -16, y: 20, name: 'leftFoot', isBody: false },
                { x: 16, y: 20, name: 'rightFoot', isBody: false },
                { x: 0, y: 20, name: 'midFoot', isBody: false },
            ];

            return localPoints.map(p => ({
                x: ship.x + p.x * cos - p.y * sin,
                y: ship.y + p.x * sin + p.y * cos,
                localX: p.x,
                localY: p.y,
                name: p.name,
                isBody: p.isBody
            }));
        }

        function getGroundYAt(x) {
            for (let i = 0; i < terrain.length - 1; i++) {
                if (terrain[i].x <= x && terrain[i + 1].x > x) {
                    const t = (x - terrain[i].x) / (terrain[i + 1].x - terrain[i].x);
                    return terrain[i].y + t * (terrain[i + 1].y - terrain[i].y);
                }
            }
            return canvas.height;
        }

        function createExplosion(x, y) {
            for (let i = 0; i < 30; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = 2 + Math.random() * 4;
                explosionParticles.push({
                    x: x, y: y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed - 2,
                    life: 1.0,
                    size: 3 + Math.random() * 5,
                    color: Math.random() > 0.5 ? '#f80' : '#ff0'
                });
            }
            ship.fireX = x;
            ship.fireY = y;
            ship.fireActive = true;
        }

        function updateExplosion() {
            for (let i = explosionParticles.length - 1; i >= 0; i--) {
                const p = explosionParticles[i];
                p.x += p.vx;
                p.y += p.vy;
                p.vy += 0.1;
                p.life -= 0.02;
                if (p.life <= 0) explosionParticles.splice(i, 1);
            }

            if (ship.fireActive && Math.random() > 0.3) {
                fireParticles.push({
                    x: ship.fireX + (Math.random() - 0.5) * 30,
                    y: ship.fireY,
                    vx: (Math.random() - 0.5) * 0.5,
                    vy: -1 - Math.random() * 2,
                    life: 1.0,
                    size: 4 + Math.random() * 6
                });
            }

            for (let i = fireParticles.length - 1; i >= 0; i--) {
                const p = fireParticles[i];
                p.x += p.vx;
                p.y += p.vy;
                p.life -= 0.03;
                p.size *= 0.98;
                if (p.life <= 0) fireParticles.splice(i, 1);
            }
        }

        function drawExplosionAndFire() {
            for (const p of explosionParticles) {
                ctx.globalAlpha = p.life;
                ctx.fillStyle = p.color;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size * p.life, 0, Math.PI * 2);
                ctx.fill();
            }
            for (const p of fireParticles) {
                ctx.globalAlpha = p.life * 0.8;
                ctx.fillStyle = `rgb(255,${Math.floor(200 * p.life)},0)`;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.globalAlpha = 1.0;
        }

        function triggerCrash(reason) {
            gameState = 'crashed';
            createExplosion(ship.x, ship.y + ship.height / 4);
            ship.visible = false;
            showMessage(reason ? `CRASHED!\n${reason}` : 'CRASHED!', '#f00');
            radioGameEnd(false);
        }

        function startContactPhysics(groundY) {
            const impactSpeed = Math.sqrt(ship.vx * ship.vx + ship.vy * ship.vy);

            if (impactSpeed > CRASH_VELOCITY) {
                triggerCrash('Impact too hard!');
                return;
            }

            gameState = 'contacting';
            ship.contactTime = 0;
            ship.pivotPoint = null;

            // Find which corner touched first
            const corners = getShipCorners();
            let firstContact = null;
            let deepestPen = -Infinity;

            for (const corner of corners) {
                const gY = getGroundYAt(corner.x);
                const pen = corner.y - gY;
                if (pen > deepestPen) {
                    deepestPen = pen;
                    firstContact = { ...corner, groundY: gY };
                }
            }

            if (firstContact) {
                // Initial contact - set up physics, but don't absorb energy instantly
                // Energy will be absorbed gradually in updateContactPhysics

                // Just record that we've made contact - physics continues naturally
                ship.firstContactPoint = firstContact;
            }
        }

        function updateContactPhysics() {
            ship.contactTime++;

            // Apply gravity - always active
            ship.vy += GRAVITY;

            const corners = getShipCorners();

            // Find all corners contacting or penetrating ground
            let contacts = [];
            for (const corner of corners) {
                const gY = getGroundYAt(corner.x);
                const penetration = corner.y - gY;
                if (penetration > -1) {
                    contacts.push({ ...corner, groundY: gY, penetration });
                }
            }

            if (contacts.length === 0) {
                // Airborne - apply velocities
                ship.x += ship.vx;
                ship.y += ship.vy;
                ship.angle += ship.angularVel;

                // Check if ship left the screen
                if (ship.x < -ship.width || ship.x > canvas.width + ship.width || ship.y < -ship.height) {
                    gameState = 'lost';
                    ship.visible = false;
                    showMessage('MISSION FAILED!\nSpaceship lost contact\nwith Mission Control!', '#f80');
                }
                return;
            }

            // Separate feet and body contacts
            const feetInContact = contacts.filter(c => !c.isBody);
            const bodyInContact = contacts.filter(c => c.isBody);

            // Check if body hit the ground - that's a crash
            if (bodyInContact.length > 0) {
                triggerCrash('Ship tipped over!');
                return;
            }

            // Find primary contact point
            let pivot = feetInContact[0];
            if (!pivot) return;

            for (const c of feetInContact) {
                if (c.penetration > pivot.penetration) {
                    pivot = c;
                }
            }

            // === REALISTIC GROUND CONTACT PHYSICS ===

            // Normal force = how hard we're pressing into ground
            // Based on downward velocity and penetration
            const normalForce = Math.max(0, ship.vy * 2 + pivot.penetration * 0.5);

            // Check for structural damage from impact
            if (normalForce > STRUCTURAL_LIMIT) {
                triggerCrash('Impact too hard!');
                return;
            }

            // Friction force opposes horizontal motion
            // F_friction = Î¼ Ã— F_normal
            const frictionForce =  0.1+ GROUND_FRICTION_COEF * normalForce;

            // Apply friction to horizontal velocity (opposes motion)
            if (Math.abs(ship.vx) > 0.001) {
                const frictionDecel = frictionForce * Math.sign(ship.vx);
                // Friction can't reverse direction, only slow down
                if (Math.abs(frictionDecel) > Math.abs(ship.vx)) {
                    ship.vx = 0;
                } else {
                    ship.vx -= frictionDecel * 0.1;
                }
            }

            // Ground reaction absorbs vertical energy gradually
            // Harder impact = more energy absorbed per frame
            const verticalDamping = Math.min(0.8, normalForce * 0.3);
            if (ship.vy > 0) {
                ship.vy *= (1 - verticalDamping);
            }

            // Vector from contact point to ship center (COM)
            const rx = ship.x - pivot.x;
            const ry = ship.y - pivot.groundY;
            const distToPivot = Math.sqrt(rx * rx + ry * ry);

            // Torques from various sources:
            const tiltFromVertical = Math.sin(ship.angle);

            // 1. Horizontal momentum creates rotation (body wants to keep moving)
            const horizontalTorque = ship.vx * Math.abs(ry) * 0.02;

            // 2. Vertical impact creates rotation if ship is tilted
            const verticalTorque = normalForce * tiltFromVertical * 0.015;

            // 3. Gravity torque pulls COM down around pivot
            const gravityTorque = rx * GRAVITY * 30;

            // Apply torques
            ship.angularVel += (horizontalTorque + verticalTorque + gravityTorque) / MOMENT_OF_INERTIA;

            // Angular damping from ground contact
            const angularDamping = feetInContact.length > 1 ? 0.90 : 0.97;
            ship.angularVel *= angularDamping;

            // Rotate ship around pivot point
            if (distToPivot > 1 && Math.abs(ship.angularVel) > 0.0001) {
                const currentAngle = Math.atan2(ry, rx);
                const newAngle = currentAngle + ship.angularVel;

                ship.x = pivot.x + Math.cos(newAngle) * distToPivot;
                ship.y = pivot.groundY + Math.sin(newAngle) * distToPivot;
            }

            // Apply velocities - ship slides along ground
            ship.x += ship.vx;
            ship.y += ship.vy;
            ship.angle += ship.angularVel;

            // Correct penetration - push out of ground
            const updatedCorners = getShipCorners();
            let maxPenetration = 0;
            for (const corner of updatedCorners) {
                const gY = getGroundYAt(corner.x);
                const pen = corner.y - gY;
                if (pen > maxPenetration) {
                    maxPenetration = pen;
                }
            }
            if (maxPenetration > 0) {
                ship.y -= maxPenetration;
                if (ship.vy > 0) ship.vy *= 0.5;
            }

            // Check for stable state (both feet on ground, very low angular velocity)
            const stableAngle = ((ship.angle % (Math.PI * 2)) + Math.PI * 2) % (Math.PI * 2);
            const isUpright = stableAngle < MAX_LANDING_ANGLE || stableAngle > (Math.PI * 2 - MAX_LANDING_ANGLE);

            // Check if on landing pad
            const onPad = ship.x >= landingPad.x && ship.x <= landingPad.x + landingPad.width;

            // Check speeds
            const isStopped = Math.abs(ship.vx) < 0.02 && Math.abs(ship.vy) < 0.02 && Math.abs(ship.angularVel) < 0.001;

            if (feetInContact.length >= 2 && isStopped && isUpright) {
                ship.vx = 0;
                ship.vy = 0;
                ship.angularVel = 0;
                gameState = 'landed';

                if (onPad) {
                    showMessage('LANDED!', '#0f0');
                } else {
                    showMessage('LANDED!\nMissed the pad', '#ff0');
                }
                radioGameEnd(true);
                return;
            }

            // Check if nearly stopped but tilted - gravity will eventually tip it
            if (Math.abs(ship.angularVel) < 0.0005 && Math.abs(ship.vx) < 0.02 && Math.abs(ship.vy) < 0.02 && ship.contactTime > 120) {
                if (isUpright) {
                    ship.vx = 0;
                    ship.vy = 0;
                    ship.angularVel = 0;
                    gameState = 'landed';

                    if (onPad) {
                        showMessage('LANDED!', '#0f0');
                    } else {
                        showMessage('LANDED!\nMissed the pad', '#ff0');
                    }
                    radioGameEnd(true);
                } else {
                    // At unstable equilibrium - give tiny nudge in tipping direction
                    if (stableAngle < Math.PI) {
                        ship.angularVel = 0.002;
                    } else {
                        ship.angularVel = -0.002;
                    }
                }
            }

            // Timeout safety
            if (ship.contactTime > 800) {
                triggerCrash(null);
            }
        }

        function showMessage(text, color) {
            const msg = document.getElementById('message');
            const restartText = isMobile ? 'Tap to restart' : 'Press R to restart';
            msg.innerHTML = text + '<br><br><span style="font-size: 16px">' + restartText + '</span>';
            msg.style.color = color;
            msg.style.display = 'block';
        }

        // Mobile detection flag (will be set later, but needed here)
        let isMobile = false;

        function draw() {
            // Clear canvas
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw stars
            stars.forEach(star => {
                const flicker = 0.5 + Math.sin(Date.now() * 0.001 * star.brightness) * 0.5;
                ctx.fillStyle = `rgba(255, 255, 255, ${flicker * star.brightness})`;
                ctx.beginPath();
                ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);
                ctx.fill();
            });

            // Draw terrain
            ctx.fillStyle = '#444';
            ctx.strokeStyle = '#888';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(0, canvas.height);
            terrain.forEach(point => {
                ctx.lineTo(point.x, point.y);
            });
            ctx.lineTo(canvas.width, canvas.height);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();

            // Draw landing pad
            ctx.fillStyle = '#0a0';
            ctx.fillRect(landingPad.x, landingPad.y - 5, landingPad.width, 8);

            // Draw landing pad markers
            ctx.fillStyle = '#0f0';
            ctx.fillRect(landingPad.x, landingPad.y - 15, 4, 15);
            ctx.fillRect(landingPad.x + landingPad.width - 4, landingPad.y - 15, 4, 15);

            // Blinking lights on landing pad
            if (Math.floor(Date.now() / 500) % 2 === 0) {
                ctx.fillStyle = '#ff0';
                ctx.beginPath();
                ctx.arc(landingPad.x + 2, landingPad.y - 15, 3, 0, Math.PI * 2);
                ctx.arc(landingPad.x + landingPad.width - 2, landingPad.y - 15, 3, 0, Math.PI * 2);
                ctx.fill();
            }

            // Draw ship (only if visible)
            if (ship.visible) {
                ctx.save();
                ctx.translate(ship.x, ship.y);
                ctx.rotate(ship.angle);

                // Draw thrust flame
                if (ship.thrusting && gameState === 'playing') {
                    ctx.fillStyle = '#f80';
                    const flameLength = 15 + Math.random() * 15;
                    ctx.beginPath();
                    ctx.moveTo(-6, ship.height / 2 - 5);
                    ctx.lineTo(6, ship.height / 2 - 5);
                    ctx.lineTo(0, ship.height / 2 + flameLength);
                    ctx.closePath();
                    ctx.fill();

                    ctx.fillStyle = '#ff0';
                    ctx.beginPath();
                    ctx.moveTo(-3, ship.height / 2 - 5);
                    ctx.lineTo(3, ship.height / 2 - 5);
                    ctx.lineTo(0, ship.height / 2 + flameLength * 0.6);
                    ctx.closePath();
                    ctx.fill();
                }

                // Draw spaceship image (use processed transparent version)
                if (shipImgReady) {
                    ctx.drawImage(shipImgTransparent, -ship.width / 2, -ship.height / 2, ship.width, ship.height);
                } else {
                    // Fallback lander drawing
                    // Body
                    ctx.fillStyle = '#ccc';
                    ctx.beginPath();
                    ctx.moveTo(-12, -15);
                    ctx.lineTo(12, -15);
                    ctx.lineTo(15, 5);
                    ctx.lineTo(-15, 5);
                    ctx.closePath();
                    ctx.fill();

                    // Cockpit
                    ctx.fillStyle = '#4af';
                    ctx.beginPath();
                    ctx.arc(0, -8, 8, Math.PI, 0);
                    ctx.fill();

                    // Landing legs
                    ctx.strokeStyle = '#ff0';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.moveTo(-12, 5);
                    ctx.lineTo(-18, 20);
                    ctx.moveTo(12, 5);
                    ctx.lineTo(18, 20);
                    ctx.stroke();

                    // Feet
                    ctx.beginPath();
                    ctx.moveTo(-22, 20);
                    ctx.lineTo(-14, 20);
                    ctx.moveTo(14, 20);
                    ctx.lineTo(22, 20);
                    ctx.stroke();
                }

                ctx.restore();

                // Draw velocity indicator
                if (gameState === 'playing') {
                    ctx.strokeStyle = '#ff0';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(ship.x, ship.y);
                    ctx.lineTo(ship.x + ship.vx * 20, ship.y + ship.vy * 20);
                    ctx.stroke();
                }
            }

            // Draw explosion and fire effects
            drawExplosionAndFire();
        }

        // Simple frame-limited game loop
        let lastTime = 0;

        function gameLoop(currentTime) {
            const elapsed = currentTime - lastTime;

            // Run at ~60fps - skip if too soon
            if (elapsed >= 16) {
                lastTime = currentTime;
                update();
                draw();
            }

            requestAnimationFrame(gameLoop);
        }

        // Event listeners
        document.addEventListener('keydown', (e) => {
            keys[e.code] = true;

            if (e.code === 'KeyR') {
                init();
            }

            // Prevent scrolling with arrow keys
            if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'Space'].includes(e.code)) {
                e.preventDefault();
            }
        });

        document.addEventListener('keyup', (e) => {
            keys[e.code] = false;
        });

        // Mobile detection and controls
        isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)
                   || ('ontouchstart' in window);

        let gyroEnabled = false;
        let gyroWorking = false; // True only after we receive valid gyro data
        let gyroGamma = 0; // Left/right tilt (-90 to 90)
        let smoothedGamma = 0; // Smoothed value for less jittery control
        let touchThrusting = false;
        let touchRotatingLeft = false;
        let touchRotatingRight = false;

        const mobileControls = document.getElementById('mobileControls');
        const thrustButton = document.getElementById('thrustButton');
        const rotateLeftBtn = document.getElementById('rotateLeftBtn');
        const rotateRightBtn = document.getElementById('rotateRightBtn');
        const gyroPrompt = document.getElementById('gyroPrompt');
        const enableGyroBtn = document.getElementById('enableGyro');

        if (isMobile) {
            document.body.classList.add('mobile');
            mobileControls.style.display = 'flex';

            // Check if we need to request permission (iOS 13+)
            if (typeof DeviceOrientationEvent !== 'undefined' &&
                typeof DeviceOrientationEvent.requestPermission === 'function') {
                // iOS - need to request permission
                gyroPrompt.style.display = 'flex';
            } else if ('DeviceOrientationEvent' in window) {
                // Android or older iOS - try to enable directly
                enableGyroscope();
            }
        }

        // Enable gyroscope button click
        enableGyroBtn.addEventListener('click', async () => {
            try {
                if (typeof DeviceOrientationEvent.requestPermission === 'function') {
                    const permission = await DeviceOrientationEvent.requestPermission();
                    if (permission === 'granted') {
                        enableGyroscope();
                    }
                }
            } catch (e) {
                console.error('Gyroscope permission error:', e);
            }
            gyroPrompt.style.display = 'none';
        });

        function enableGyroscope() {
            window.addEventListener('deviceorientation', handleOrientation, true);
            gyroEnabled = true;

            // Give it 2 seconds to see if we get valid data
            setTimeout(() => {
                if (!gyroWorking) {
                    console.log('Gyroscope not providing data, using button controls');
                    gyroEnabled = false;
                }
            }, 2000);
        }

        let gyroSampleCount = 0;
        function handleOrientation(event) {
            // Detect screen orientation
            const isLandscape = window.innerWidth > window.innerHeight;

            let tilt;
            if (isLandscape) {
                // In landscape mode, use beta for left/right tilt
                // Beta ranges from -180 to 180, we want the range around 0 (flat)
                // When phone is landscape and tilted left, beta decreases
                // When phone is landscape and tilted right, beta increases
                tilt = event.beta || 0;
                // Clamp beta to reasonable range and invert if needed
                if (Math.abs(tilt) > 90) {
                    tilt = tilt > 0 ? 180 - tilt : -180 - tilt;
                }
            } else {
                // In portrait mode, use gamma for left/right tilt
                tilt = event.gamma || 0;
            }

            // Check if we're getting real data (not just zeros)
            gyroSampleCount++;
            if (gyroSampleCount > 5 && (Math.abs(event.gamma || 0) > 0.5 || Math.abs(event.beta || 0) > 0.5 || Math.abs(event.alpha || 0) > 0)) {
                if (!gyroWorking) {
                    gyroWorking = true;
                    document.body.classList.add('gyro-active');
                    console.log('Gyroscope working!');
                }
            }

            gyroGamma = tilt || 0;
        }

        // Thrust button touch events
        thrustButton.addEventListener('touchstart', (e) => {
            e.preventDefault();
            touchThrusting = true;
            thrustButton.classList.add('active');
        }, { passive: false });

        thrustButton.addEventListener('touchend', (e) => {
            e.preventDefault();
            touchThrusting = false;
            thrustButton.classList.remove('active');
        }, { passive: false });

        thrustButton.addEventListener('touchcancel', (e) => {
            touchThrusting = false;
            thrustButton.classList.remove('active');
        });

        // Rotation button touch events (fallback when gyro doesn't work)
        rotateLeftBtn.addEventListener('touchstart', (e) => {
            e.preventDefault();
            touchRotatingLeft = true;
            rotateLeftBtn.classList.add('active');
        }, { passive: false });

        rotateLeftBtn.addEventListener('touchend', (e) => {
            e.preventDefault();
            touchRotatingLeft = false;
            rotateLeftBtn.classList.remove('active');
        }, { passive: false });

        rotateLeftBtn.addEventListener('touchcancel', () => {
            touchRotatingLeft = false;
            rotateLeftBtn.classList.remove('active');
        });

        rotateRightBtn.addEventListener('touchstart', (e) => {
            e.preventDefault();
            touchRotatingRight = true;
            rotateRightBtn.classList.add('active');
        }, { passive: false });

        rotateRightBtn.addEventListener('touchend', (e) => {
            e.preventDefault();
            touchRotatingRight = false;
            rotateRightBtn.classList.remove('active');
        }, { passive: false });

        rotateRightBtn.addEventListener('touchcancel', () => {
            touchRotatingRight = false;
            rotateRightBtn.classList.remove('active');
        });

        // Prevent default touch behavior on canvas to avoid scrolling
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            // Tap anywhere on screen (except thrust button) to restart when game over
            if (gameState !== 'playing' && gameState !== 'contacting') {
                init();
            }
        }, { passive: false });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
        }, { passive: false });

        // Modify the update function to handle mobile input
        const originalUpdate = update;
        update = function() {
            // Handle touch thrust
            if (touchThrusting && gameState === 'playing') {
                keys['Space'] = true;
            } else if (isMobile) {
                keys['Space'] = false;
            }

            // Handle touch rotation buttons (only on mobile when gyro not working)
            if (isMobile && !gyroWorking && gameState === 'playing') {
                if (touchRotatingLeft) {
                    keys['ArrowLeft'] = true;
                } else if (!keys['KeyA']) {  // Don't override physical keyboard
                    keys['ArrowLeft'] = false;
                }
                if (touchRotatingRight) {
                    keys['ArrowRight'] = true;
                } else if (!keys['KeyD']) {  // Don't override physical keyboard
                    keys['ArrowRight'] = false;
                }
            }

            // Always smooth the gyro input so it's ready
            if (gyroEnabled) {
                smoothedGamma += (gyroGamma - smoothedGamma) * 0.2;
            }

            // Call original update first
            originalUpdate();

            // AFTER original update: override angle with gyroscope (only if gyro is working)
            // This ensures gyro takes precedence over any keyboard input
            if (gyroWorking && gameState === 'playing') {
                // Directly map phone tilt to ship angle
                // Clamp to reasonable range (-60 to 60 degrees)
                const maxTilt = 60;
                const clampedTilt = Math.max(-maxTilt, Math.min(maxTilt, smoothedGamma));
                ship.angle = clampedTilt * (Math.PI / 180); // Convert degrees to radians
            }
        };

        // Start game immediately
        init();
        requestAnimationFrame(gameLoop);
    </script>
</body>
</html>
