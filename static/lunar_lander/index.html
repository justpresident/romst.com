<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lunar Lander</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            background: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: 'Courier New', monospace;
            color: #0f0;
        }
        #gameContainer {
            position: relative;
        }
        canvas {
            display: block;
            border: 2px solid #333;
        }
        #hud {
            position: absolute;
            top: 10px;
            left: 10px;
            font-size: 14px;
            line-height: 1.6;
            text-shadow: 0 0 5px #0f0;
        }
        #message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 24px;
            text-align: center;
            display: none;
            text-shadow: 0 0 10px currentColor;
        }
        #instructions {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 12px;
            text-align: center;
            opacity: 0.7;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="game"></canvas>
        <div id="hud">
            <div>FUEL: <span id="fuel">100</span>%</div>
            <div>ALTITUDE: <span id="altitude">0</span>m</div>
            <div>HORIZONTAL: <span id="hSpeed">0</span>m/s</div>
            <div>VERTICAL: <span id="vSpeed">0</span>m/s</div>
        </div>
        <div id="message"></div>
        <div id="instructions">
            ARROW KEYS or WASD to control | SPACE for thrust | R to restart
        </div>
    </div>

    <script>
        const canvas = document.getElementById('game');
        const ctx = canvas.getContext('2d');

        // Set canvas size
        canvas.width = 800;
        canvas.height = 600;

        // Load spaceship image and make black background transparent
        const shipImg = new Image();
        const shipImgTransparent = document.createElement('canvas');
        let shipImgReady = false;

        shipImg.onload = function() {
            // Create a canvas to process the image
            shipImgTransparent.width = shipImg.width;
            shipImgTransparent.height = shipImg.height;
            const imgCtx = shipImgTransparent.getContext('2d');
            imgCtx.drawImage(shipImg, 0, 0);

            // Get image data and make black pixels transparent
            const imageData = imgCtx.getImageData(0, 0, shipImg.width, shipImg.height);
            const data = imageData.data;

            for (let i = 0; i < data.length; i += 4) {
                // Check if pixel is black or very dark (threshold of 30)
                if (data[i] < 30 && data[i + 1] < 30 && data[i + 2] < 30) {
                    data[i + 3] = 0; // Set alpha to 0 (transparent)
                }
            }

            imgCtx.putImageData(imageData, 0, 0);
            shipImgReady = true;
        };

        shipImg.src = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEgAAAA7CAYAAADYW8woAAAACXBIWXMAAA7EAAAOxAGVKw4bAAACSElEQVR4Xu2ZO5LCMBBE21t7LAg4GAT4YARwL28AY8TsSC0byRD0i/DYiCrpufVhADBBZPnxBfGKOoigDiL8+sIWnM9nAMDhcAAA7Ha79DYAYBzHl2t7dr/fv9R7I4MI3Q26Xq++NBtzu93cnTyXywXAs72tTJJBhG4G2UjbyKf4WpRBObxJQF+bZBBBHUQY0HirMU335vw0DQCn4/G1MAwAnt9JGR734O6dH+2eTqe51jO4ZRChW0gb6UjDPgfGUB5GWWu22EzpYZIMInQ3KMTypYbMs1EG9UAGEbobFM1QtsWwRV8040UZw2iZPYYMIqiDCN1fsQh7tWrOeHKvmkL6S+hmkI2wWQLkd+2RASWrtkQGEZoZ5Kdzu543nYhNWYqZGbWlrcYHaGZQjtQssyk3M6X4E8mSOUZLcwwZRGh+YGZEeeBr/jrCG+O/m9Z6IIMI6iDCW69YsFFfhf1/mK4jfS13XaLFmyeDCKumeTMnPexbY5O3ImrPP7PEnDTf19okgwirDGqFWTGO94XjND2PMPzfYmtMaoEMIiwyKMqedzBzjse7OVEG5UyqIc0dy6OlWSSDCIsMaoU3J7LCai1MegcZRFAHEaq2GjWLwCXB7V8bXwfy93w9onBkNFMb1jKIsCika0avBh+4pXZrnvGU7KixK0UGEYoZtGb01lDKuF6/XbtwlEGERRnUC59Jae3TyCCCOojwL6Q/qfknfpuFtQwiqIMI6iDCnEGlxZrROxe2yKCarUaaRzKI8G8W25JvsJYhgwh/c+Hrbq9qJiwAAAAASUVORK5CYII=';

        // Game constants
        const GRAVITY = 0.02;
        const THRUST = 0.05;
        const ROTATION_SPEED = 0.05;
        const MAX_LANDING_SPEED = 1.5;
        const MAX_LANDING_ANGLE = 0.3;
        const FUEL_CONSUMPTION = 0.2;

        // Game state
        let ship = {};
        let terrain = [];
        let landingPad = {};
        let gameState = 'playing'; // 'playing', 'landed', 'crashed', 'contacting'
        let stars = [];

        // Input state
        const keys = {};

        // Initialize game
        function init() {
            // Reset ship
            ship = {
                x: 100 + Math.random() * 200,
                y: 80,
                vx: 0.5 + Math.random() * 0.5,
                vy: 0,
                angle: 0,
                angularVel: 0,  // Angular velocity for physics
                width: 40,
                height: 44,
                fuel: 100,
                thrusting: false,
                visible: true,
                // Physics properties for contact
                contactTime: 0,
                fireActive: false
            };

            // Reset explosion/fire particles
            explosionParticles = [];
            fireParticles = [];

            // Generate terrain
            generateTerrain();

            // Generate stars
            stars = [];
            for (let i = 0; i < 100; i++) {
                stars.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height * 0.7,
                    size: Math.random() * 2 + 0.5,
                    brightness: Math.random()
                });
            }

            gameState = 'playing';
            document.getElementById('message').style.display = 'none';
        }

        function generateTerrain() {
            terrain = [];
            const segments = 40;
            const segmentWidth = canvas.width / segments;

            // Pick a random spot for landing pad (not too close to edges)
            const padSegment = Math.floor(5 + Math.random() * (segments - 10));
            const padWidth = 4; // segments wide

            let y = canvas.height - 100 - Math.random() * 100;

            for (let i = 0; i <= segments; i++) {
                // Create flat landing pad area
                if (i >= padSegment && i <= padSegment + padWidth) {
                    if (i === padSegment) {
                        landingPad = {
                            x: i * segmentWidth,
                            y: y,
                            width: padWidth * segmentWidth
                        };
                    }
                    terrain.push({ x: i * segmentWidth, y: y });
                } else {
                    // Random terrain
                    y += (Math.random() - 0.5) * 40;
                    y = Math.max(canvas.height - 250, Math.min(canvas.height - 50, y));
                    terrain.push({ x: i * segmentWidth, y: y });
                }
            }
        }

        function update() {
            // Always update explosion/fire effects
            updateExplosion();

            if (gameState === 'contacting') {
                updateContactPhysics();
                return;
            }

            if (gameState !== 'playing') return;

            // Apply gravity
            ship.vy += GRAVITY;

            // Handle input
            ship.thrusting = false;

            if ((keys['ArrowUp'] || keys['KeyW'] || keys['Space']) && ship.fuel > 0) {
                ship.vx += Math.sin(ship.angle) * THRUST;
                ship.vy -= Math.cos(ship.angle) * THRUST;
                ship.fuel -= FUEL_CONSUMPTION;
                ship.thrusting = true;
            }

            if (keys['ArrowLeft'] || keys['KeyA']) {
                ship.angle -= ROTATION_SPEED;
            }

            if (keys['ArrowRight'] || keys['KeyD']) {
                ship.angle += ROTATION_SPEED;
            }

            // Update position
            ship.x += ship.vx;
            ship.y += ship.vy;

            // Screen wrapping (horizontal)
            if (ship.x < -ship.width) ship.x = canvas.width;
            if (ship.x > canvas.width) ship.x = -ship.width;

            // Check collision with terrain
            checkCollision();

            // Update HUD
            document.getElementById('fuel').textContent = Math.max(0, Math.floor(ship.fuel));
            document.getElementById('altitude').textContent = Math.max(0, Math.floor(getAltitude()));
            document.getElementById('hSpeed').textContent = (ship.vx * 10).toFixed(1);
            document.getElementById('vSpeed').textContent = (ship.vy * 10).toFixed(1);
        }

        function getAltitude() {
            // Find terrain height below ship
            for (let i = 0; i < terrain.length - 1; i++) {
                if (terrain[i].x <= ship.x && terrain[i + 1].x > ship.x) {
                    const t = (ship.x - terrain[i].x) / (terrain[i + 1].x - terrain[i].x);
                    const groundY = terrain[i].y + t * (terrain[i + 1].y - terrain[i].y);
                    return groundY - ship.y - ship.height / 2;
                }
            }
            return canvas.height - ship.y;
        }

        function checkCollision() {
            // Use actual ship corners for collision - not bounding box
            const corners = getShipCorners();

            // Check if any corner touches the ground
            for (const corner of corners) {
                const groundY = getGroundYAt(corner.x);
                if (corner.y >= groundY) {
                    // Actual contact - start physics simulation
                    // Same behavior for landing pad and terrain
                    startContactPhysics(groundY);
                    return;
                }
            }

            // Check ceiling
            if (ship.y < 0) {
                ship.y = 0;
                ship.vy = Math.abs(ship.vy) * 0.5;
            }
        }

        // Physics constants - heavy spacecraft
        const CRASH_VELOCITY = 1.2;        // Velocity for immediate explosion (displayed as 12 m/s)
        const SAFE_VERTICAL_SPEED = 0.15;   // Max vertical speed for safe landing (3 m/s displayed)
        const SAFE_HORIZONTAL_SPEED = 0.3; // Max horizontal speed for safe landing (5 m/s displayed)
        const GROUND_FRICTION_COEF = 0.4;  // Friction coefficient (μ)
        const MOMENT_OF_INERTIA = 5000;    // Heavy ship resists rotation
        const STRUCTURAL_LIMIT = 1.5;      // Impact force that damages the ship

        // Explosion/fire particles
        let explosionParticles = [];
        let fireParticles = [];

        // Ship corner positions relative to center (for collision detection)
        function getShipCorners() {
            const cos = Math.cos(ship.angle);
            const sin = Math.sin(ship.angle);

            // Define ship shape: body corners and leg feet
            const localPoints = [
                { x: -10, y: -18, name: 'bodyLeft', isBody: true },
                { x: 10, y: -18, name: 'bodyRight', isBody: true },
                { x: -16, y: 20, name: 'leftFoot', isBody: false },
                { x: 16, y: 20, name: 'rightFoot', isBody: false },
            ];

            return localPoints.map(p => ({
                x: ship.x + p.x * cos - p.y * sin,
                y: ship.y + p.x * sin + p.y * cos,
                localX: p.x,
                localY: p.y,
                name: p.name,
                isBody: p.isBody
            }));
        }

        function getGroundYAt(x) {
            for (let i = 0; i < terrain.length - 1; i++) {
                if (terrain[i].x <= x && terrain[i + 1].x > x) {
                    const t = (x - terrain[i].x) / (terrain[i + 1].x - terrain[i].x);
                    return terrain[i].y + t * (terrain[i + 1].y - terrain[i].y);
                }
            }
            return canvas.height;
        }

        function createExplosion(x, y) {
            for (let i = 0; i < 30; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = 2 + Math.random() * 4;
                explosionParticles.push({
                    x: x, y: y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed - 2,
                    life: 1.0,
                    size: 3 + Math.random() * 5,
                    color: Math.random() > 0.5 ? '#f80' : '#ff0'
                });
            }
            ship.fireX = x;
            ship.fireY = y;
            ship.fireActive = true;
        }

        function updateExplosion() {
            for (let i = explosionParticles.length - 1; i >= 0; i--) {
                const p = explosionParticles[i];
                p.x += p.vx;
                p.y += p.vy;
                p.vy += 0.1;
                p.life -= 0.02;
                if (p.life <= 0) explosionParticles.splice(i, 1);
            }

            if (ship.fireActive && Math.random() > 0.3) {
                fireParticles.push({
                    x: ship.fireX + (Math.random() - 0.5) * 30,
                    y: ship.fireY,
                    vx: (Math.random() - 0.5) * 0.5,
                    vy: -1 - Math.random() * 2,
                    life: 1.0,
                    size: 4 + Math.random() * 6
                });
            }

            for (let i = fireParticles.length - 1; i >= 0; i--) {
                const p = fireParticles[i];
                p.x += p.vx;
                p.y += p.vy;
                p.life -= 0.03;
                p.size *= 0.98;
                if (p.life <= 0) fireParticles.splice(i, 1);
            }
        }

        function drawExplosionAndFire() {
            for (const p of explosionParticles) {
                ctx.globalAlpha = p.life;
                ctx.fillStyle = p.color;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size * p.life, 0, Math.PI * 2);
                ctx.fill();
            }
            for (const p of fireParticles) {
                ctx.globalAlpha = p.life * 0.8;
                ctx.fillStyle = `rgb(255,${Math.floor(200 * p.life)},0)`;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.globalAlpha = 1.0;
        }

        function triggerCrash(reason) {
            gameState = 'crashed';
            createExplosion(ship.x, ship.y + ship.height / 4);
            ship.visible = false;
            showMessage(reason ? `CRASHED!\n${reason}` : 'CRASHED!', '#f00');
        }

        function startContactPhysics(groundY) {
            const impactSpeed = Math.sqrt(ship.vx * ship.vx + ship.vy * ship.vy);

            if (impactSpeed > CRASH_VELOCITY) {
                triggerCrash('Impact too hard!');
                return;
            }

            gameState = 'contacting';
            ship.contactTime = 0;
            ship.pivotPoint = null;

            // Find which corner touched first
            const corners = getShipCorners();
            let firstContact = null;
            let deepestPen = -Infinity;

            for (const corner of corners) {
                const gY = getGroundYAt(corner.x);
                const pen = corner.y - gY;
                if (pen > deepestPen) {
                    deepestPen = pen;
                    firstContact = { ...corner, groundY: gY };
                }
            }

            if (firstContact) {
                // Initial contact - set up physics, but don't absorb energy instantly
                // Energy will be absorbed gradually in updateContactPhysics

                // Just record that we've made contact - physics continues naturally
                ship.firstContactPoint = firstContact;
            }
        }

        function updateContactPhysics() {
            ship.contactTime++;

            // Apply gravity - always active
            ship.vy += GRAVITY;

            const corners = getShipCorners();

            // Find all corners contacting or penetrating ground
            let contacts = [];
            for (const corner of corners) {
                const gY = getGroundYAt(corner.x);
                const penetration = corner.y - gY;
                if (penetration > -1) {
                    contacts.push({ ...corner, groundY: gY, penetration });
                }
            }

            if (contacts.length === 0) {
                // Airborne - apply velocities
                ship.x += ship.vx;
                ship.y += ship.vy;
                ship.angle += ship.angularVel;
                return;
            }

            // Separate feet and body contacts
            const feetInContact = contacts.filter(c => !c.isBody);
            const bodyInContact = contacts.filter(c => c.isBody);

            // Check if body hit the ground - that's a crash
            if (bodyInContact.length > 0) {
                triggerCrash('Ship tipped over!');
                return;
            }

            // Find primary contact point
            let pivot = feetInContact[0];
            if (!pivot) return;

            for (const c of feetInContact) {
                if (c.penetration > pivot.penetration) {
                    pivot = c;
                }
            }

            // === REALISTIC GROUND CONTACT PHYSICS ===

            // Normal force = how hard we're pressing into ground
            // Based on downward velocity and penetration
            const normalForce = Math.max(0, ship.vy * 2 + pivot.penetration * 0.5);

            // Check for structural damage from impact
            if (normalForce > STRUCTURAL_LIMIT) {
                triggerCrash('Impact too hard!');
                return;
            }

            // Friction force opposes horizontal motion
            // F_friction = μ × F_normal
            const frictionForce =  0.1+ GROUND_FRICTION_COEF * normalForce;

            // Apply friction to horizontal velocity (opposes motion)
            if (Math.abs(ship.vx) > 0.001) {
                const frictionDecel = frictionForce * Math.sign(ship.vx);
                // Friction can't reverse direction, only slow down
                if (Math.abs(frictionDecel) > Math.abs(ship.vx)) {
                    ship.vx = 0;
                } else {
                    ship.vx -= frictionDecel * 0.1;
                }
            }

            // Ground reaction absorbs vertical energy gradually
            // Harder impact = more energy absorbed per frame
            const verticalDamping = Math.min(0.8, normalForce * 0.3);
            if (ship.vy > 0) {
                ship.vy *= (1 - verticalDamping);
            }

            // Vector from contact point to ship center (COM)
            const rx = ship.x - pivot.x;
            const ry = ship.y - pivot.groundY;
            const distToPivot = Math.sqrt(rx * rx + ry * ry);

            // Torques from various sources:
            const tiltFromVertical = Math.sin(ship.angle);

            // 1. Horizontal momentum creates rotation (body wants to keep moving)
            const horizontalTorque = ship.vx * Math.abs(ry) * 0.02;

            // 2. Vertical impact creates rotation if ship is tilted
            const verticalTorque = normalForce * tiltFromVertical * 0.015;

            // 3. Gravity torque pulls COM down around pivot
            const gravityTorque = rx * GRAVITY * 30;

            // Apply torques
            ship.angularVel += (horizontalTorque + verticalTorque + gravityTorque) / MOMENT_OF_INERTIA;

            // Angular damping from ground contact
            const angularDamping = feetInContact.length > 1 ? 0.90 : 0.97;
            ship.angularVel *= angularDamping;

            // Rotate ship around pivot point
            if (distToPivot > 1 && Math.abs(ship.angularVel) > 0.0001) {
                const currentAngle = Math.atan2(ry, rx);
                const newAngle = currentAngle + ship.angularVel;

                ship.x = pivot.x + Math.cos(newAngle) * distToPivot;
                ship.y = pivot.groundY + Math.sin(newAngle) * distToPivot;
            }

            // Apply velocities - ship slides along ground
            ship.x += ship.vx;
            ship.y += ship.vy;
            ship.angle += ship.angularVel;

            // Correct penetration - push out of ground
            const updatedCorners = getShipCorners();
            let maxPenetration = 0;
            for (const corner of updatedCorners) {
                const gY = getGroundYAt(corner.x);
                const pen = corner.y - gY;
                if (pen > maxPenetration) {
                    maxPenetration = pen;
                }
            }
            if (maxPenetration > 0) {
                ship.y -= maxPenetration;
                if (ship.vy > 0) ship.vy *= 0.5;
            }

            // Check for stable state (both feet on ground, very low angular velocity)
            const stableAngle = ((ship.angle % (Math.PI * 2)) + Math.PI * 2) % (Math.PI * 2);
            const isUpright = stableAngle < MAX_LANDING_ANGLE || stableAngle > (Math.PI * 2 - MAX_LANDING_ANGLE);

            // Check if on landing pad
            const onPad = ship.x >= landingPad.x && ship.x <= landingPad.x + landingPad.width;

            // Check speeds
            const isStopped = Math.abs(ship.vx) < 0.02 && Math.abs(ship.vy) < 0.02 && Math.abs(ship.angularVel) < 0.001;

            if (feetInContact.length >= 2 && isStopped && isUpright) {
                ship.vx = 0;
                ship.vy = 0;
                ship.angularVel = 0;
                gameState = 'landed';

                if (onPad) {
                    showMessage('LANDED!', '#0f0');
                } else {
                    showMessage('LANDED!\nMissed the pad', '#ff0');
                }
                return;
            }

            // Check if nearly stopped but tilted - gravity will eventually tip it
            if (Math.abs(ship.angularVel) < 0.0005 && Math.abs(ship.vx) < 0.02 && Math.abs(ship.vy) < 0.02 && ship.contactTime > 120) {
                if (isUpright) {
                    ship.vx = 0;
                    ship.vy = 0;
                    ship.angularVel = 0;
                    gameState = 'landed';

                    if (onPad) {
                        showMessage('LANDED!', '#0f0');
                    } else {
                        showMessage('LANDED!\nMissed the pad', '#ff0');
                    }
                } else {
                    // At unstable equilibrium - give tiny nudge in tipping direction
                    if (stableAngle < Math.PI) {
                        ship.angularVel = 0.002;
                    } else {
                        ship.angularVel = -0.002;
                    }
                }
            }

            // Timeout safety
            if (ship.contactTime > 800) {
                triggerCrash(null);
            }

            // Keep on screen
            ship.x = Math.max(20, Math.min(canvas.width - 20, ship.x));
        }

        function showMessage(text, color) {
            const msg = document.getElementById('message');
            msg.innerHTML = text + '<br><br><span style="font-size: 16px">Press R to restart</span>';
            msg.style.color = color;
            msg.style.display = 'block';
        }

        function draw() {
            // Clear canvas
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw stars
            stars.forEach(star => {
                const flicker = 0.5 + Math.sin(Date.now() * 0.001 * star.brightness) * 0.5;
                ctx.fillStyle = `rgba(255, 255, 255, ${flicker * star.brightness})`;
                ctx.beginPath();
                ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);
                ctx.fill();
            });

            // Draw terrain
            ctx.fillStyle = '#444';
            ctx.strokeStyle = '#888';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(0, canvas.height);
            terrain.forEach(point => {
                ctx.lineTo(point.x, point.y);
            });
            ctx.lineTo(canvas.width, canvas.height);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();

            // Draw landing pad
            ctx.fillStyle = '#0a0';
            ctx.fillRect(landingPad.x, landingPad.y - 5, landingPad.width, 8);

            // Draw landing pad markers
            ctx.fillStyle = '#0f0';
            ctx.fillRect(landingPad.x, landingPad.y - 15, 4, 15);
            ctx.fillRect(landingPad.x + landingPad.width - 4, landingPad.y - 15, 4, 15);

            // Blinking lights on landing pad
            if (Math.floor(Date.now() / 500) % 2 === 0) {
                ctx.fillStyle = '#ff0';
                ctx.beginPath();
                ctx.arc(landingPad.x + 2, landingPad.y - 15, 3, 0, Math.PI * 2);
                ctx.arc(landingPad.x + landingPad.width - 2, landingPad.y - 15, 3, 0, Math.PI * 2);
                ctx.fill();
            }

            // Draw ship (only if visible)
            if (ship.visible) {
                ctx.save();
                ctx.translate(ship.x, ship.y);
                ctx.rotate(ship.angle);

                // Draw thrust flame
                if (ship.thrusting && gameState === 'playing') {
                    ctx.fillStyle = '#f80';
                    const flameLength = 15 + Math.random() * 15;
                    ctx.beginPath();
                    ctx.moveTo(-6, ship.height / 2 - 5);
                    ctx.lineTo(6, ship.height / 2 - 5);
                    ctx.lineTo(0, ship.height / 2 + flameLength);
                    ctx.closePath();
                    ctx.fill();

                    ctx.fillStyle = '#ff0';
                    ctx.beginPath();
                    ctx.moveTo(-3, ship.height / 2 - 5);
                    ctx.lineTo(3, ship.height / 2 - 5);
                    ctx.lineTo(0, ship.height / 2 + flameLength * 0.6);
                    ctx.closePath();
                    ctx.fill();
                }

                // Draw spaceship image (use processed transparent version)
                if (shipImgReady) {
                    ctx.drawImage(shipImgTransparent, -ship.width / 2, -ship.height / 2, ship.width, ship.height);
                } else {
                    // Fallback lander drawing
                    // Body
                    ctx.fillStyle = '#ccc';
                    ctx.beginPath();
                    ctx.moveTo(-12, -15);
                    ctx.lineTo(12, -15);
                    ctx.lineTo(15, 5);
                    ctx.lineTo(-15, 5);
                    ctx.closePath();
                    ctx.fill();

                    // Cockpit
                    ctx.fillStyle = '#4af';
                    ctx.beginPath();
                    ctx.arc(0, -8, 8, Math.PI, 0);
                    ctx.fill();

                    // Landing legs
                    ctx.strokeStyle = '#ff0';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.moveTo(-12, 5);
                    ctx.lineTo(-18, 20);
                    ctx.moveTo(12, 5);
                    ctx.lineTo(18, 20);
                    ctx.stroke();

                    // Feet
                    ctx.beginPath();
                    ctx.moveTo(-22, 20);
                    ctx.lineTo(-14, 20);
                    ctx.moveTo(14, 20);
                    ctx.lineTo(22, 20);
                    ctx.stroke();
                }

                ctx.restore();

                // Draw velocity indicator
                if (gameState === 'playing') {
                    ctx.strokeStyle = '#ff0';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(ship.x, ship.y);
                    ctx.lineTo(ship.x + ship.vx * 20, ship.y + ship.vy * 20);
                    ctx.stroke();
                }
            }

            // Draw explosion and fire effects
            drawExplosionAndFire();
        }

        function gameLoop() {
            update();
            draw();
            requestAnimationFrame(gameLoop);
        }

        // Event listeners
        document.addEventListener('keydown', (e) => {
            keys[e.code] = true;

            if (e.code === 'KeyR') {
                init();
            }

            // Prevent scrolling with arrow keys
            if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'Space'].includes(e.code)) {
                e.preventDefault();
            }
        });

        document.addEventListener('keyup', (e) => {
            keys[e.code] = false;
        });

        // Start game immediately
        init();
        gameLoop();
    </script>
</body>
</html>
