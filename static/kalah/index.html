<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Super-Kalah</title>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@500;700&family=Crimson+Text:wght@400;600&display=swap" rel="stylesheet">
    <style>
        * {
            box-sizing: border-box;
        }

        body {
            font-family: 'Crimson Text', Georgia, serif;
            background:
                radial-gradient(ellipse at top, #2d2418 0%, #1a1510 50%, #0f0d0a 100%);
            min-height: 100vh;
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            overflow-x: hidden;
            position: relative;
        }

        /* Subtle ambient glow */
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background:
                radial-gradient(ellipse at 20% 20%, rgba(180, 140, 80, 0.08) 0%, transparent 50%),
                radial-gradient(ellipse at 80% 80%, rgba(120, 90, 60, 0.06) 0%, transparent 50%);
            pointer-events: none;
            z-index: 0;
        }

        h1 {
            font-family: 'Cinzel', serif;
            font-size: 2.8em;
            font-weight: 700;
            color: #c9a961;
            text-shadow: 0 2px 4px rgba(0,0,0,0.5), 0 0 30px rgba(180, 140, 80, 0.3);
            margin-bottom: 5px;
            z-index: 1;
            letter-spacing: 0.1em;
        }

        .subtitle {
            font-size: 1.1em;
            color: #8b7355;
            margin-bottom: 15px;
            z-index: 1;
            font-style: italic;
        }

        .game-container {
            z-index: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        /* Language selector */
        .lang-selector {
            position: fixed;
            top: 20px;
            left: 80px;
            display: flex;
            gap: 5px;
            z-index: 100;
        }

        .lang-btn {
            width: 36px;
            height: 36px;
            border-radius: 6px;
            border: 1px solid #5a4a35;
            cursor: pointer;
            font-family: 'Cinzel', serif;
            font-size: 0.75em;
            font-weight: 500;
            display: flex;
            align-items: center;
            justify-content: center;
            background: linear-gradient(145deg, #3d3225, #2a231b);
            color: #a89070;
            box-shadow: 0 4px 15px rgba(0,0,0,0.4);
            transition: all 0.3s;
            padding: 0;
        }

        .lang-btn:hover {
            transform: scale(1.05);
            border-color: #8b7355;
            color: #c9a961;
        }

        .lang-btn.active {
            border-color: #c9a961;
            color: #c9a961;
            box-shadow: 0 0 12px rgba(180, 140, 80, 0.3);
        }

        .settings {
            background: linear-gradient(145deg, #2d2418, #1f1a14);
            padding: 20px 30px;
            border-radius: 16px;
            margin-bottom: 15px;
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            justify-content: center;
            align-items: center;
            box-shadow: 0 8px 25px rgba(0,0,0,0.4), inset 0 1px 0 rgba(255,255,255,0.05);
            border: 1px solid #4a3c2a;
        }

        .settings-group {
            display: flex;
            align-items: center;
            gap: 6px;
            background: linear-gradient(145deg, #252018, #1a1510);
            padding: 8px 14px;
            border-radius: 10px;
            border: 1px solid #3a3025;
        }

        .settings-group:hover {
            border-color: #5a4a35;
        }

        .settings-icon {
            font-size: 1.2em;
            opacity: 0.7;
            min-width: 20px;
            text-align: center;
        }

        .settings label {
            display: flex;
            align-items: center;
            gap: 8px;
            font-weight: 600;
            color: #a89070;
            font-size: 0.95em;
        }

        .settings input, .settings select {
            padding: 8px 12px;
            border-radius: 6px;
            border: 1px solid #4a3c2a;
            background: linear-gradient(145deg, #1a1510, #0f0d0a);
            color: #d4c4a8;
            font-size: 1em;
            font-family: 'Crimson Text', serif;
            font-weight: 600;
            transition: all 0.3s;
        }

        .settings input:focus, .settings select:focus {
            outline: none;
            border-color: #c9a961;
            box-shadow: 0 0 10px rgba(180, 140, 80, 0.3);
        }

        .settings select option {
            background: #1a1510;
            color: #d4c4a8;
        }

        /* Custom number input with spinner */
        .number-input-wrapper {
            display: flex;
            align-items: center;
            background: linear-gradient(145deg, #1a1510, #0f0d0a);
            border-radius: 6px;
            border: 1px solid #4a3c2a;
            overflow: hidden;
            transition: all 0.3s;
        }

        .number-input-wrapper:hover,
        .number-input-wrapper:focus-within {
            border-color: #c9a961;
            box-shadow: 0 0 10px rgba(180, 140, 80, 0.2);
        }

        .number-input-wrapper input[type="number"] {
            width: 45px;
            padding: 8px 4px;
            border: none;
            background: transparent;
            text-align: center;
            font-size: 1.1em;
            -moz-appearance: textfield;
        }

        .number-input-wrapper input[type="number"]::-webkit-outer-spin-button,
        .number-input-wrapper input[type="number"]::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }

        .number-input-wrapper input[type="number"]:focus {
            outline: none;
            box-shadow: none;
        }

        .number-btn {
            width: 28px;
            height: 36px;
            border: none;
            background: linear-gradient(145deg, #3a3025, #2a231b);
            color: #a89070;
            font-size: 1.1em;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            padding: 0;
        }

        .number-btn:hover {
            background: linear-gradient(145deg, #4a4035, #3a3025);
            color: #c9a961;
        }

        .number-btn:active {
            background: linear-gradient(145deg, #2a231b, #3a3025);
        }

        .settings select {
            padding: 8px 30px 8px 12px;
            appearance: none;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 12 12'%3E%3Cpath fill='%23a89070' d='M6 8L1 3h10z'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 10px center;
            cursor: pointer;
            min-width: 120px;
        }

        .settings input[type="checkbox"] {
            width: 20px;
            height: 20px;
            cursor: pointer;
            accent-color: #c9a961;
        }

        .checkbox-wrapper {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
        }

        .checkbox-wrapper input[type="checkbox"] {
            position: relative;
            width: 18px;
            height: 18px;
            appearance: none;
            background: linear-gradient(145deg, #1a1510, #0f0d0a);
            border: 1px solid #4a3c2a;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .checkbox-wrapper input[type="checkbox"]:checked {
            background: linear-gradient(145deg, #5a4a35, #4a3c2a);
            border-color: #c9a961;
        }

        .checkbox-wrapper input[type="checkbox"]:checked::after {
            content: '‚úì';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #c9a961;
            font-size: 12px;
            font-weight: bold;
        }

        .checkbox-wrapper:hover input[type="checkbox"] {
            border-color: #6a5a45;
        }

        .settings-divider {
            width: 1px;
            height: 30px;
            background: linear-gradient(to bottom, transparent, #4a3c2a, transparent);
            margin: 0 8px;
        }

        .player-banner {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px 20px;
            border-radius: 8px;
            font-weight: 600;
            font-size: 1em;
            transition: all 0.3s;
            font-family: 'Cinzel', serif;
            letter-spacing: 0.05em;
        }

        .player-banner.computer {
            background: rgba(90, 60, 40, 0.3);
            color: #a08060;
            border: 1px solid transparent;
        }

        .player-banner.player {
            background: rgba(60, 90, 70, 0.3);
            color: #80a090;
            border: 1px solid transparent;
        }

        .player-banner.active {
            transform: scale(1.05);
            animation: glow 1.5s ease-in-out infinite alternate;
        }

        .player-banner.computer.active {
            background: linear-gradient(145deg, #5a4030, #4a3020);
            color: #d4c4a8;
            border-color: #8b6040;
        }

        .player-banner.player.active {
            background: linear-gradient(145deg, #2a5040, #1f4030);
            color: #b0d0c0;
            border-color: #4a8060;
        }

        @keyframes glow {
            from { box-shadow: 0 0 8px rgba(180, 140, 80, 0.3); }
            to { box-shadow: 0 0 20px rgba(180, 140, 80, 0.5); }
        }

        .board-wrapper {
            position: relative;
        }

        .board {
            display: flex;
            align-items: center;
            gap: 15px;
            background: linear-gradient(145deg, #5a4a35, #4a3c2a);
            padding: 25px;
            border-radius: 20px;
            box-shadow: 0 15px 40px rgba(0,0,0,0.5), inset 0 2px 0 rgba(255,255,255,0.1);
            border: 3px solid #6b5a45;
            position: relative;
        }

        .board::before {
            content: '';
            position: absolute;
            inset: 8px;
            border: 1px solid rgba(100, 80, 60, 0.3);
            border-radius: 15px;
            pointer-events: none;
        }

        .kalah {
            width: 90px;
            height: 220px;
            background: linear-gradient(180deg, #3d3225 0%, #252018 100%);
            border-radius: 45px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-family: 'Cinzel', serif;
            font-size: 2.2em;
            font-weight: 700;
            color: #c9a961;
            box-shadow: inset 0 8px 20px rgba(0,0,0,0.6), 0 4px 10px rgba(0,0,0,0.4);
            border: 2px solid #4a3c2a;
            position: relative;
            overflow: hidden;
        }

        .kalah::before {
            content: '';
            position: absolute;
            top: 10px;
            left: 10px;
            right: 10px;
            height: 30px;
            background: linear-gradient(180deg, rgba(255,255,255,0.08), transparent);
            border-radius: 40px 40px 0 0;
        }

        .kalah-label {
            font-size: 0.35em;
            color: #8b7355;
            margin-top: 5px;
            letter-spacing: 0.1em;
        }

        .kalah.receiving {
            animation: kalah-pulse 0.3s ease-out;
        }

        @keyframes kalah-pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.03); box-shadow: inset 0 8px 20px rgba(0,0,0,0.6), 0 0 25px rgba(180, 140, 80, 0.4); }
            100% { transform: scale(1); }
        }

        .pits-container {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .pits-row {
            display: flex;
            gap: 12px;
        }

        .pit {
            width: 70px;
            height: 70px;
            background: linear-gradient(180deg, #3d3225 0%, #252018 100%);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: 'Cinzel', serif;
            font-size: 1.4em;
            font-weight: 700;
            color: #c9a961;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: inset 0 6px 15px rgba(0,0,0,0.6), 0 4px 8px rgba(0,0,0,0.4);
            border: 2px solid #4a3c2a;
            position: relative;
            overflow: visible;
        }

        .pit::before {
            content: '';
            position: absolute;
            top: 5px;
            left: 15%;
            right: 15%;
            height: 15px;
            background: linear-gradient(180deg, rgba(255,255,255,0.08), transparent);
            border-radius: 50%;
        }

        .pit:hover:not(.disabled) {
            transform: scale(1.1);
            box-shadow: inset 0 6px 15px rgba(0,0,0,0.6), 0 8px 25px rgba(180, 140, 80, 0.4);
            border-color: #8b7355;
        }

        .pit.disabled {
            cursor: not-allowed;
            opacity: 0.8;
        }

        .pit.highlight {
            animation: bounce-pit 0.6s ease-in-out;
            box-shadow: inset 0 6px 15px rgba(0,0,0,0.6), 0 0 25px rgba(180, 140, 80, 0.5);
        }

        .pit.receiving {
            animation: receive-stone 0.3s ease-out;
            box-shadow: inset 0 6px 15px rgba(0,0,0,0.6), 0 0 20px rgba(100, 140, 110, 0.4);
        }

        .pit.emptying {
            animation: empty-pit 0.4s ease-out;
        }

        @keyframes bounce-pit {
            0%, 100% { transform: scale(1); }
         Super    30% { transform: scale(1.15); }
            60% { transform: scale(1.1); }
        }

        @keyframes receive-stone {
            0% { transform: scale(1); }
            50% { transform: scale(1.08); }
            100% { transform: scale(1); }
        }

        @keyframes empty-pit {
            0% { transform: scale(1); }
            50% { transform: scale(0.95); opacity: 0.8; }
            100% { transform: scale(1); opacity: 1; }
        }

        .pit-number {
            position: absolute;
            font-family: 'Cinzel', serif;
            font-size: 0.5em;
            font-weight: 500;
            padding: 2px 8px;
            border-radius: 6px;
            background: rgba(45, 36, 24, 0.9);
            color: #a89070;
            border: 1px solid #5a4a35;
        }

        .top-row .pit-number {
            top: -25px;
        }

        .bottom-row .pit-number {
            bottom: -25px;
        }

        /* Stone visualization */
        .stones {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 2px;
            max-width: 50px;
        }

        .stone {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            display: inline-block;
        }

        /* Flying stone animation */
        .flying-stone {
            position: fixed;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            z-index: 10000;
            pointer-events: none;
            box-shadow: 0 2px 4px rgba(0,0,0,0.4), inset -2px -2px 4px rgba(0,0,0,0.3);
        }

        /* Hand/scoop animation for picking up stones */
        .scoop-effect {
            position: absolute;
            font-size: 1.5em;
            z-index: 1001;
            pointer-events: none;
            animation: scoop 0.4s ease-out forwards;
            filter: grayscale(0.3);
        }

        @keyframes scoop {
            0% {
                transform: scale(0);
                opacity: 0;
            }
            50% {
                transform: scale(1.1);
                opacity: 0.7;
            }
            100% {
                transform: scale(1);
                opacity: 0;
            }
        }

        button {
            padding: 12px 24px;
            font-family: 'Cinzel', serif;
            font-size: 1em;
            font-weight: 500;
            letter-spacing: 0.05em;
            cursor: pointer;
            background: linear-gradient(145deg, #5a4a35, #4a3c2a);
            color: #d4c4a8;
            border: 1px solid #6b5a45;
            border-radius: 8px;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
            position: relative;
            top: 0;
        }

        button:hover:not(:disabled) {
            transform: translateY(-2px);
            background: linear-gradient(145deg, #6b5a45, #5a4a35);
            box-shadow: 0 6px 20px rgba(0,0,0,0.4);
            border-color: #8b7355;
        }

        button:active:not(:disabled) {
            top: 2px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        button.secondary {
            background: linear-gradient(145deg, #3a4a40, #2a3a30);
            border-color: #4a5a50;
        }

        button.secondary:hover:not(:disabled) {
            background: linear-gradient(145deg, #4a5a50, #3a4a40);
            border-color: #5a6a60;
        }

        .message {
            margin-top: 20px;
            padding: 18px 35px;
            background: linear-gradient(145deg, #2d2418, #1f1a14);
            border-radius: 10px;
            font-size: 1.2em;
            font-weight: 600;
            min-height: 55px;
            text-align: center;
            box-shadow: 0 8px 25px rgba(0,0,0,0.4);
            border: 1px solid #4a3c2a;
            color: #a89070;
        }

        .message.your-turn {
            color: #90b0a0;
            border-color: #4a6a5a;
        }

        .message.computer-turn {
            color: #b09070;
            border-color: #6a5040;
        }

        .message.game-over {
            background: linear-gradient(145deg, #4a4030, #3a3020);
            color: #c9a961;
            font-size: 1.3em;
            border-color: #6a5a40;
        }

        .controls {
            margin-top: 20px;
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            justify-content: center;
        }

        /* Speed control */
        .speed-control {
            display: flex;
            align-items: center;
            gap: 12px;
            background: linear-gradient(145deg, #252018, #1a1510);
            padding: 10px 18px;
            border-radius: 10px;
            margin-top: 12px;
            border: 1px solid #3a3025;
        }

        .speed-control:hover {
            border-color: #5a4a35;
        }

        .speed-control .speed-icon {
            font-size: 1em;
            color: #8b7355;
        }

        .speed-control span {
            font-weight: 600;
            color: #8b7355;
            font-size: 0.9em;
        }

        .speed-control input[type="range"] {
            width: 120px;
            height: 6px;
            cursor: pointer;
            accent-color: #c9a961;
            background: linear-gradient(to right, #4a3c2a, #6a5a45);
            border-radius: 3px;
            -webkit-appearance: none;
            appearance: none;
        }

        .speed-control input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: linear-gradient(145deg, #c9a961, #a08050);
            cursor: pointer;
            border: 2px solid #5a4a35;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }

        .speed-control input[type="range"]::-moz-range-thumb {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: linear-gradient(145deg, #c9a961, #a08050);
            cursor: pointer;
            border: 2px solid #5a4a35;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }

        /* Celebration effect */
        .confetti {
            position: fixed;
            pointer-events: none;
            z-index: 1000;
        }

        .confetti-piece {
            position: absolute;
            width: 12px;
            height: 12px;
            animation: confetti-fall 3s ease-out forwards;
        }

        @keyframes confetti-fall {
            0% {
                opacity: 0.8;
                transform: translateY(0) rotate(0deg);
            }
            100% {
                opacity: 0;
                transform: translateY(100vh) rotate(720deg);
            }
        }

        /* Sound toggle */
        .sound-toggle {
            position: fixed;
            top: 20px;
            left: 20px;
            background: linear-gradient(145deg, #3d3225, #2a231b);
            border: 2px solid #5a4a35;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            font-size: 1.5em;
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(0,0,0,0.4);
            z-index: 100;
            transition: all 0.3s;
        }

        .sound-toggle:hover {
            transform: scale(1.1);
            border-color: #8b7355;
        }

        /* Rules Modal */
        .rules-modal {
            display: none;
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.85);
            z-index: 1000;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .rules-modal.show {
            display: flex;
        }

        .rules-content {
            background: linear-gradient(145deg, #2d2418, #1f1a14);
            border: 2px solid #6b5a45;
            border-radius: 16px;
            padding: 0;
            width: 95%;
            max-width: 700px;
            max-height: 85vh;
            box-shadow: 0 15px 50px rgba(0, 0, 0, 0.6), 0 0 40px rgba(180, 140, 80, 0.15);
            position: relative;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .rules-header {
            padding: 20px 50px 0 25px;
            border-bottom: 1px solid #4a3c2a;
            flex-shrink: 0;
        }

        .rules-title {
            font-family: 'Cinzel', serif;
            font-size: 1.5em;
            color: #c9a961;
            margin: 0 0 15px 0;
            text-align: center;
            letter-spacing: 0.05em;
        }

        .rules-tabs {
            display: flex;
            gap: 5px;
            flex-wrap: wrap;
        }

        .rules-tab {
            padding: 10px 16px;
            background: transparent;
            border: 1px solid transparent;
            border-bottom: none;
            border-radius: 8px 8px 0 0;
            color: #8b7355;
            font-family: 'Cinzel', serif;
            font-size: 0.85em;
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
            top: 1px;
        }

        .rules-tab:hover {
            color: #c9a961;
            background: rgba(74, 60, 42, 0.3);
        }

        .rules-tab.active {
            background: linear-gradient(145deg, #2d2418, #252018);
            border-color: #4a3c2a;
            color: #c9a961;
        }

        .rules-body {
            padding: 25px;
            overflow-y: auto;
            flex: 1;
        }

        .rules-body::-webkit-scrollbar {
            width: 8px;
        }

        .rules-body::-webkit-scrollbar-track {
            background: #1a1510;
            border-radius: 4px;
        }

        .rules-body::-webkit-scrollbar-thumb {
            background: #4a3c2a;
            border-radius: 4px;
        }

        .rules-body::-webkit-scrollbar-thumb:hover {
            background: #5a4a35;
        }

        .rules-close {
            position: absolute;
            top: 15px;
            right: 15px;
            width: 32px;
            height: 32px;
            border: 1px solid #4a3c2a;
            background: linear-gradient(145deg, #3a3025, #2a231b);
            color: #a89070;
            font-size: 1.2em;
            cursor: pointer;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            padding: 0;
            z-index: 10;
        }

        .rules-close:hover {
            background: linear-gradient(145deg, #4a4035, #3a3025);
            color: #c9a961;
            border-color: #6b5a45;
        }

        .rules-panel {
            display: none;
        }

        .rules-panel.active {
            display: block;
        }

        .rules-section {
            margin-bottom: 25px;
        }

        .rules-section:last-child {
            margin-bottom: 0;
        }

        .rules-section-title {
            font-family: 'Cinzel', serif;
            font-size: 1.1em;
            color: #c9a961;
            margin: 0 0 12px 0;
            padding-bottom: 8px;
            border-bottom: 1px solid #3a3025;
        }

        .rules-text {
            font-family: 'Crimson Text', Georgia, serif;
            font-size: 1.05em;
            line-height: 1.7;
            color: #b8a888;
        }

        .rules-text p {
            margin: 0 0 12px 0;
        }

        .rules-text p:last-child {
            margin-bottom: 0;
        }

        .rules-text strong {
            color: #c9a961;
            font-weight: 600;
        }

        .rules-text em {
            color: #90b0a0;
            font-style: normal;
            font-weight: 600;
        }

        .rules-list {
            list-style: none;
            padding: 0;
            margin: 12px 0;
            color: #a89070;
        }

        .rules-list li {
            padding: 8px 0 8px 28px;
            position: relative;
            border-bottom: 1px solid #2a231b;
        }

        .rules-list li:last-child {
            border-bottom: none;
        }

        .rules-list li::before {
            content: attr(data-num);
            position: absolute;
            left: 0;
            color: #90b0a0;
            font-weight: 600;
            font-family: 'Cinzel', serif;
        }
        .rules-list strong {
            color: #c9a961;
            font-weight: 600;
        }

        .rules-callout {
            background: linear-gradient(145deg, #352a1f, #2a2318);
            border-left: 3px solid #c9a961;
            padding: 12px 15px;
            margin: 15px 0;
            border-radius: 0 8px 8px 0;
            color: #a89070;
        }

        .rules-callout p {
            margin: 0;
        }

        /* Board Diagram */
        .board-diagram {
            display: flex;
            justify-content: center;
            margin: 20px 0;
        }

        .board-diagram svg {
            max-width: 100%;
            height: auto;
        }

        .diagram-caption {
            text-align: center;
            font-size: 0.9em;
            color: #8b7355;
            margin-top: 8px;
            font-style: italic;
        }

        .rules-author {
            text-align: center;
            padding: 20px;
            background: linear-gradient(145deg, #352a1f, #2a2318);
            border-radius: 10px;
            margin-top: 15px;
        }

        .rules-author-label {
            font-size: 0.9em;
            color: #8b7355;
            margin-bottom: 8px;
        }

        .rules-author-name {
            font-family: 'Cinzel', serif;
            font-size: 1.15em;
            color: #c9a961;
        }

        /* Responsive */
        @media (max-width: 768px) {
            h1 { font-size: 1.8em; }
            .pit { width: 50px; height: 50px; font-size: 1.1em; }
            .kalah { width: 60px; height: 150px; font-size: 1.6em; }
            .board { padding: 15px; gap: 8px; }
            .pits-row { gap: 6px; }
            .settings { padding: 10px 15px; }
            .lang-selector { left: 75px; }
            .rules-content { max-width: 95%; }
            .rules-header { padding: 15px 45px 0 15px; }
            .rules-body { padding: 15px; }
            .rules-tab { padding: 8px 12px; font-size: 0.8em; }
            .rules-title { font-size: 1.3em; }
        }
    </style>
</head>
<body>
    <button class="sound-toggle" onclick="toggleSound()" id="soundBtn">&#128266;</button>

    <!-- Language selector -->
    <div class="lang-selector">
        <button class="lang-btn active" onclick="setLanguage('en')" id="langEn" title="English">EN</button>
        <button class="lang-btn" onclick="setLanguage('ru')" id="langRu" title="–†—É—Å—Å–∫–∏–π">RU</button>
    </div>

    <div class="game-container">
        <h1 id="title">Kalah</h1>
        <p class="subtitle" id="subtitle">The Ancient Game of Strategy</p>

        <div class="settings">
            <div class="settings-group">
                <span class="settings-icon">‚óã</span>
                <label>
                    <span id="labelPits">Pits:</span>
                </label>
                <div class="number-input-wrapper">
                    <button type="button" class="number-btn" onclick="adjustNumber('numPits', -1)">‚àí</button>
                    <input type="number" id="numPits" value="6" min="3" max="10">
                    <button type="button" class="number-btn" onclick="adjustNumber('numPits', 1)">+</button>
                </div>
            </div>
            <div class="settings-group">
                <span class="settings-icon">‚óè</span>
                <label>
                    <span id="labelStones">Stones:</span>
                </label>
                <div class="number-input-wrapper">
                    <button type="button" class="number-btn" onclick="adjustNumber('numStones', -1)">‚àí</button>
                    <input type="number" id="numStones" value="6" min="1" max="10">
                    <button type="button" class="number-btn" onclick="adjustNumber('numStones', 1)">+</button>
                </div>
            </div>
            <div class="settings-divider"></div>
            <div class="settings-group">
                <span class="settings-icon">‚óÜ</span>
                <label>
                    <span id="labelLevel">Level:</span>
                </label>
                <select id="difficulty">
                    <option value="1" id="levelEasy">Novice</option>
                    <option value="2" id="levelMedium">Candidate</option>
                    <option value="3" selected id="levelHard">Master</option>
                    <option value="4" id="levelWizard">Effendi</option>
                </select>
            </div>
            <div class="settings-divider"></div>
            <div class="settings-group">
                <label class="checkbox-wrapper">
                    <input type="checkbox" id="playerFirst" checked>
                    <span id="labelYouFirst">You go first</span>
                </label>
            </div>
            <button onclick="newGame()" id="newGameBtn">New Game</button>
        </div>

        <div class="player-banner computer" id="computerLabel">Opponent</div>
        <div class="board-wrapper">
            <div class="board" id="board"></div>
        </div>
        <div class="player-banner player" id="playerLabel">You</div>

        <div class="speed-control">
            <span class="speed-icon">üê¢</span>
            <input type="range" id="speedSlider" min="200" max="450" value="400">
            <span class="speed-icon">üêá</span>
            <span id="speedLabel">Animation Speed</span>
        </div>

        <div class="message" id="message">Press "New Game" to begin</div>

        <div class="controls">
            <button class="secondary" onclick="getHint()" id="hintBtn">Hint</button>
            <button class="secondary" onclick="undoMove()" id="undoBtn">Undo</button>
            <button class="secondary" onclick="showRules()" id="rulesBtn">Rules</button>
        </div>
    </div>

    <!-- Rules Modal -->
    <div class="rules-modal" id="rulesModal" onclick="hideRules(event)">
        <div class="rules-content" onclick="event.stopPropagation()">
            <button class="rules-close" onclick="hideRules()">&times;</button>
            <div class="rules-header">
                <h2 class="rules-title" id="rulesTitle">Rules</h2>
                <div class="rules-tabs" id="rulesTabs"></div>
            </div>
            <div class="rules-body" id="rulesBody"></div>
        </div>
    </div>

    <div class="confetti" id="confetti"></div>

    <script>
        // ===================
        // TRANSLATIONS
        // ===================
        const translations = {
            en: {
                title: "Super Kalah",
                subtitle: "The Ancient Game of Strategy",
                labelPits: "Pits:",
                labelStones: "Stones:",
                labelLevel: "Level:",
                levelEasy: "Novice",
                levelMedium: "Candidate",
                levelHard: "Master",
                levelWizard: "Effendi",
                labelYouFirst: "You go first",
                newGame: "New Game",
                computerLabel: "Opponent",
                playerLabel: "You",
                speedLabel: "Animation Speed",
                hintBtn: "Hint",
                undoBtn: "Undo",
                rulesBtn: "Rules",
                rulesTitle: "Game Rules",
                rulesTabs: ["How to Play", "Super-Kalah"],
                rulesContent: {
                    basics: {
                        intro: {
                            title: "Introduction",
                            text: "Kalah is an ancient African logic game. The rules are extremely simple. However, despite the apparent simplicity, the game requires significant mental effort and ultimate concentration. The game develops attentiveness, logical abilities, and spatial imagination."
                        },
                        setup: {
                            title: "Game Board",
                            text: "The game involves <strong>two players</strong>. Each player has <strong>six pits</strong>, each initially containing <strong>six stones</strong>. Additionally, each player has one large pit ‚Äî the <strong>kalah</strong>. The kalah pit is always located to the player's <strong>right</strong>."
                        },
                        movement: {
                            title: "Basic Move",
                            text: "Players take turns making a move ‚Äì they take <strong>all the stones from any one of their pits</strong> and distribute them <strong>counter-clockwise</strong> into all subsequent pits, including their own kalah and the opponent's pits, but <strong>excluding the opponent's kalah</strong>."
                        },
                        goal: {
                            title: "Victory",
                            text: "The game ends when all the pits of one of the players are empty. All remaining stones in the opponent's pits are moved to the opponent's kalah. The player who has collected the <strong>greater number of stones</strong> in their kalah by the end of the game wins."
                        }
                    },
                    special: {
                        extraTurn: {
                            title: "Extra Turn",
                            text: "If the move ends in the kalah, the player <strong>must</strong> make another move."
                        },
                        capture: {
                            title: "Capture",
                            text: "If the <strong>move ends in one's own empty pit</strong>, and there are stones in the opponent's pit directly opposite, then <strong>all stones</strong> from the opponent's pit and this pit are <strong>moved to the kalah</strong> of the player who made the move."
                        }
                    },
                    superkalah: {
                        variant: {
                            title: "Super-Kalah Variant",
                            text: "Unlike classic Kalah (6 pits with 6 stones each), in Super-Kalah you can have an <strong>arbitrary number of pits</strong>, which initially contain an <strong>arbitrary number of stones</strong>."
                        },
                        levels: {
                            title: "Difficulty Levels",
                            list: [
                                { num: "1", name: "Novice", desc: "Quick, simple moves" },
                                { num: "2", name: "Candidate", desc: "Moderate strategy" },
                                { num: "3", name: "Master", desc: "Advanced planning" },
                                { num: "4", name: "Effendi", desc: "Maximum difficulty" }
                            ],
                            text: "The higher the level, the longer the thinking time and the stronger the gameplay."
                        }
                    },
                    about: {
                        author: "Studenikin Valery Alekseevich",
                        authorLabel: "Algorithm & Program Author",
                        message: "I wish you success and a pleasant time!"
                    }
                },
                kalahYou: "YOU",
                kalahRobot: "OPP",
                // Messages
                msgStart: "Press \"New Game\" to begin",
                msgYourTurn: "Your turn - select a pit",
                msgComputerThinking: "Thinking... [{n}]",
                msgWatchStones: "Sowing stones...",
                msgExtraTurn: "Extra turn! Go again",
                msgCapture: "Capture!",
                msgTie: "Draw!",
                msgHint: "I suggest moving from pit {n}",
                // Varied end-game messages (from Pascal original)
                msgYouLose: [
                    "Sorry, you lost...",
                    "Don't despair - you'll win next time!",
                    "Next time luck should be on your side.",
                    "I suggest practicing at novice level.",
                    "Intelligence is powerless against skill!"
                ],
                msgYouWin: [
                    "Next time I'll definitely win...",
                    "Accept my congratulations!",
                    "I don't like losing, but you won.",
                    "How did I manage to lose!",
                    "It seems you won by chance."
                ],
                // Single move taunting messages
                msgOnlyOneMove: [
                    "I don't recommend moving from pit {n}!",
                    "Think carefully which pit to move from!",
                    "Interesting, which pit will you choose?",
                    "What move will you make?",
                    "I suggest moving from pit {n}!"
                ],
                // Advice prompt
                msgWantAdvice: "Do you want advice?",
                msgAdvice: "I advise making a move from pit {n}"
            },
            ru: {
                title: "–°—É–ø–µ—Ä-–ö–∞–ª–∞—Ö",
                subtitle: "–î—Ä–µ–≤–Ω—è—è –∏–≥—Ä–∞ —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏",
                labelPits: "–õ—É–Ω–∫–∏:",
                labelStones: "–ö–∞–º–Ω–∏:",
                labelLevel: "–£—Ä–æ–≤–µ–Ω—å:",
                levelEasy: "–ù–æ–≤–∏—á–æ–∫",
                levelMedium: "–ö–∞–Ω–¥–∏–¥–∞—Ç",
                levelHard: "–ú–∞—Å—Ç–µ—Ä",
                levelWizard: "–≠—Ñ–µ–Ω–¥–∏",
                labelYouFirst: "–í—ã —Ö–æ–¥–∏—Ç–µ –ø–µ—Ä–≤—ã–º",
                newGame: "–ù–æ–≤–∞—è –∏–≥—Ä–∞",
                computerLabel: "–°–æ–ø–µ—Ä–Ω–∏–∫",
                playerLabel: "–í—ã",
                speedLabel: "–°–∫–æ—Ä–æ—Å—Ç—å –∞–Ω–∏–º–∞—Ü–∏–∏",
                hintBtn: "–ü–æ–¥—Å–∫–∞–∑–∫–∞",
                undoBtn: "–û—Ç–º–µ–Ω–∞",
                rulesBtn: "–ü—Ä–∞–≤–∏–ª–∞",
                rulesTitle: "–ü—Ä–∞–≤–∏–ª–∞ –∏–≥—Ä—ã",
                rulesTabs: ["–ö–∞–∫ –∏–≥—Ä–∞—Ç—å", "–°—É–ø–µ—Ä-–ö–∞–ª–∞—Ö"],
                rulesContent: {
                    basics: {
                        intro: {
                            title: "–í–≤–µ–¥–µ–Ω–∏–µ",
                            text: "–ö–∞–ª–∞—Ö ‚Äî –¥—Ä–µ–≤–Ω—è—è –∞—Ñ—Ä–∏–∫–∞–Ω—Å–∫–∞—è –ª–æ–≥–∏—á–µ—Å–∫–∞—è –∏–≥—Ä–∞. –ü—Ä–∞–≤–∏–ª–∞ –∏–≥—Ä—ã –ø—Ä–µ–¥–µ–ª—å–Ω–æ –ø—Ä–æ—Å—Ç—ã. –ù–æ –Ω–µ—Å–º–æ—Ç—Ä—è –Ω–∞ –∫–∞–∂—É—â—É—é—Å—è –ø—Ä–æ—Å—Ç–æ—Ç—É, –∏–≥—Ä–∞ —Ç—Ä–µ–±—É–µ—Ç –æ—Ç –∏–≥—Ä–æ–∫–æ–≤ –±–æ–ª—å—à–æ–≥–æ —É–º—Å—Ç–≤–µ–Ω–Ω–æ–≥–æ –Ω–∞–ø—Ä—è–∂–µ–Ω–∏—è –∏ –ø—Ä–µ–¥–µ–ª—å–Ω–æ–≥–æ —Å–æ—Å—Ä–µ–¥–æ—Ç–æ—á–µ–Ω–∏—è. –ò–≥—Ä–∞ —Ä–∞–∑–≤–∏–≤–∞–µ—Ç –≤–Ω–∏–º–∞—Ç–µ–ª—å–Ω–æ—Å—Ç—å, –ª–æ–≥–∏—á–µ—Å–∫–∏–µ —Å–ø–æ—Å–æ–±–Ω–æ—Å—Ç–∏ –∏ –ø—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–µ–Ω–Ω–æ–µ –≤–æ–æ–±—Ä–∞–∂–µ–Ω–∏–µ."
                        },
                        setup: {
                            title: "–ò–≥—Ä–æ–≤–æ–µ –ø–æ–ª–µ",
                            text: "–í –∏–≥—Ä–µ —É—á–∞—Å—Ç–≤—É—é—Ç <strong>–¥–≤–æ–µ</strong>. –£ –∫–∞–∂–¥–æ–≥–æ –∏–º–µ–µ—Ç—Å—è –ø–æ <strong>—à–µ—Å—Ç—å –ª—É–Ω–æ–∫</strong>, –≤ –∫–∞–∂–¥–æ–π –∏–∑ –∫–æ—Ç–æ—Ä—ã—Ö –≤–Ω–∞—á–∞–ª–µ –ª–µ–∂–∏—Ç –ø–æ <strong>—à–µ—Å—Ç—å –∫–∞–º–Ω–µ–π</strong>. –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–æ –∫–∞–∂–¥—ã–π –∏–≥—Ä–æ–∫ –∏–º–µ–µ—Ç –µ—â—ë –æ–¥–Ω—É –±–æ–ª—å—à—É—é –ª—É–Ω–∫—É ‚Äî <strong>–∫–∞–ª–∞—Ö</strong>. –õ—É–Ω–∫–∞ –∫–∞–ª–∞—Ö –≤—Å–µ–≥–¥–∞ –Ω–∞—Ö–æ–¥–∏—Ç—Å—è <strong>—Å–ø—Ä–∞–≤–∞</strong> –æ—Ç –∏–≥—Ä–æ–∫–∞."
                        },
                        movement: {
                            title: "–û—Å–Ω–æ–≤–Ω–æ–π —Ö–æ–¥",
                            text: "–ò–≥—Ä–æ–∫–∏ –ø–æ–æ—á–µ—Ä—ë–¥–Ω–æ –¥–µ–ª–∞—é—Ç —Ö–æ–¥ - –±–µ—Ä—É—Ç <strong>–≤—Å–µ –∫–∞–º–Ω–∏ –∏–∑ –∫–∞–∫–æ–π-–ª–∏–±–æ —Å–≤–æ–µ–π –ª—É–Ω–∫–∏</strong> –∏ —Ä–∞—Å–∫–ª–∞–¥—ã–≤–∞—é—Ç –∏—Ö <strong>–ø—Ä–æ—Ç–∏–≤ —á–∞—Å–æ–≤–æ–π —Å—Ç—Ä–µ–ª–∫–∏</strong> –≤–æ –≤—Å–µ –ø–æ—Å–ª–µ–¥—É—é—â–∏–µ –ª—É–Ω–∫–∏, –≤–∫–ª—é—á–∞—è —Å–≤–æ–π –∫–∞–ª–∞—Ö –∏ –ª—É–Ω–∫–∏ –ø—Ä–æ—Ç–∏–≤–Ω–∏–∫–∞, –Ω–æ <strong>–∏—Å–∫–ª—é—á–∞—è –∫–∞–ª–∞—Ö –ø—Ä–æ—Ç–∏–≤–Ω–∏–∫–∞</strong>."
                        },
                        goal: {
                            title: "–ü–æ–±–µ–¥–∞",
                            text: "–ò–≥—Ä–∞ –∑–∞–∫–∞–Ω—á–∏–≤–∞–µ—Ç—Å—è, –∫–æ–≥–¥–∞ —É –æ–¥–Ω–æ–≥–æ –∏–∑ –∏–≥—Ä–æ–∫–æ–≤ –≤—Å–µ –ª—É–Ω–∫–∏ –ø—É—Å—Ç—ã. –í—Å–µ –æ—Å—Ç–∞–≤—à–∏–µ—Å—è –∫–∞–º–Ω–∏ –∏–∑ –ª—É–Ω–æ–∫ –ø—Ä–æ—Ç–∏–≤–Ω–∏–∫–∞ –ø–µ—Ä–µ—Ö–æ–¥—è—Ç –≤ –∫–∞–ª–∞—Ö –ø—Ä–æ—Ç–∏–≤–Ω–∏–∫–∞. –ò–≥—Ä–æ–∫, –Ω–∞–±—Ä–∞–≤—à–∏–π –∫ –∫–æ–Ω—Ü—É –∏–≥—Ä—ã –≤ –∫–∞–ª–∞—Ö–µ <strong>–±–æ–ª—å—à–µ–µ —á–∏—Å–ª–æ –∫–∞–º–Ω–µ–π</strong>, - –≤—ã–∏–≥—Ä—ã–≤–∞–µ—Ç."
                        }
                    },
                    special: {
                        extraTurn: {
                            title: "–î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–π —Ö–æ–¥",
                            text: "–ï—Å–ª–∏ —Ö–æ–¥ –∫–æ–Ω—á–∞–µ—Ç—Å—è –≤ –∫–∞–ª–∞—Ö–µ, —Ç–æ –∏–≥—Ä–æ–∫ <strong>–¥–æ–ª–∂–µ–Ω</strong> —Å–¥–µ–ª–∞—Ç—å –µ—â—ë –æ–¥–∏–Ω —Ö–æ–¥."
                        },
                        capture: {
                            title: "–ó–∞—Ö–≤–∞—Ç",
                            text: "–ï—Å–ª–∏ <strong>—Ö–æ–¥ –∑–∞–∫–∞–Ω—á–∏–≤–∞–µ—Ç—Å—è –≤ —Å–≤–æ–µ–π –ø—É—Å—Ç–æ–π –ª—É–Ω–∫–µ</strong>, —Ç–∞–∫ —á—Ç–æ –≤ –ª—É–Ω–∫–µ –ø—Ä–æ—Ç–∏–≤–Ω–∏–∫–∞ –Ω–∞–ø—Ä–æ—Ç–∏–≤ –∏–º–µ—é—Ç—Å—è –∫–∞–º–Ω–∏, —Ç–æ <strong>–≤—Å–µ –∫–∞–º–Ω–∏</strong> –∏–∑ –ª—É–Ω–∫–∏ –ø—Ä–æ—Ç–∏–≤–Ω–∏–∫–∞ –∏ —ç—Ç–æ–π —Å–≤–æ–µ–π –ª—É–Ω–∫–∏ <strong>–ø–µ—Ä–µ–∫–ª–∞–¥—ã–≤–∞—é—Ç—Å—è –≤ –∫–∞–ª–∞—Ö</strong> –¥–µ–ª–∞–≤—à–µ–≥–æ —Ö–æ–¥ –∏–≥—Ä–æ–∫–∞"
                        }
                    },
                    superkalah: {
                        variant: {
                            title: "–í–∞—Ä–∏–∞–Ω—Ç –°—É–ø–µ—Ä-–ö–∞–ª–∞—Ö",
                            text: "–í –æ—Ç–ª–∏—á–∏–µ –æ—Ç –∫–ª–∞—Å—Å–∏—á–µ—Å–∫–æ–≥–æ –ö–∞–ª–∞—Ö–∞ (6 –ª—É–Ω–æ–∫ –ø–æ 6 –∫–∞–º–Ω–µ–π), –≤ –°—É–ø–µ—Ä-–ö–∞–ª–∞—Ö –º–æ–∂–Ω–æ –∏–º–µ—Ç—å <strong>–ø—Ä–æ–∏–∑–≤–æ–ª—å–Ω–æ–µ —á–∏—Å–ª–æ –ª—É–Ω–æ–∫</strong>, –∫–æ—Ç–æ—Ä—ã–µ –∏–∑–Ω–∞—á–∞–ª—å–Ω–æ —Å–æ–¥–µ—Ä–∂–∞—Ç <strong>–ø—Ä–æ–∏–∑–≤–æ–ª—å–Ω–æ–µ —á–∏—Å–ª–æ –∫–∞–º–Ω–µ–π</strong>."
                        },
                        levels: {
                            title: "–£—Ä–æ–≤–Ω–∏ —Å–ª–æ–∂–Ω–æ—Å—Ç–∏",
                            list: [
                                { num: "1", name: "–ù–æ–≤–∏—á–æ–∫", desc: "–ë—ã—Å—Ç—Ä—ã–µ, –ø—Ä–æ—Å—Ç—ã–µ —Ö–æ–¥—ã" },
                                { num: "2", name: "–ö–∞–Ω–¥–∏–¥–∞—Ç", desc: "–£–º–µ—Ä–µ–Ω–Ω–∞—è —Å—Ç—Ä–∞—Ç–µ–≥–∏—è" },
                                { num: "3", name: "–ú–∞—Å—Ç–µ—Ä", desc: "–ü—Ä–æ–¥–≤–∏–Ω—É—Ç–æ–µ –ø–ª–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ" },
                                { num: "4", name: "–≠—Ñ–µ–Ω–¥–∏", desc: "–ú–∞–∫—Å–∏–º–∞–ª—å–Ω–∞—è —Å–ª–æ–∂–Ω–æ—Å—Ç—å" }
                            ],
                            text: "–ß–µ–º –≤—ã—à–µ —É—Ä–æ–≤–µ–Ω—å, —Ç–µ–º –±–æ–ª—å—à–µ –≤—Ä–µ–º—è –æ–±–¥—É–º—ã–≤–∞–Ω–∏—è –∏ —Å–∏–ª–∞ –∏–≥—Ä—ã."
                        }
                    },
                    about: {
                        author: "–°—Ç—É–¥–µ–Ω–∏–∫–∏–Ω –í–∞–ª–µ—Ä–∏–π –ê–ª–µ–∫—Å–µ–µ–≤–∏—á",
                        authorLabel: "–ê–≤—Ç–æ—Ä –∞–ª–≥–æ—Ä–∏—Ç–º–∞ –∏ —Ä–∞–∑—Ä–∞–±–æ—Ç—á–∏–∫ –ø—Ä–æ–≥—Ä–∞–º–º—ã",
                        message: "–ñ–µ–ª–∞—é –í–∞–º —É—Å–ø–µ—Ö–∞ –∏ –ø—Ä–∏—è—Ç–Ω–æ –ø—Ä–æ–≤–µ—Å—Ç–∏ –≤—Ä–µ–º—è!"
                    }
                },
                kalahYou: "–í–´",
                kalahRobot: "–°–û–ü",
                // Messages
                msgStart: "–ù–∞–∂–º–∏—Ç–µ \"–ù–æ–≤–∞—è –∏–≥—Ä–∞\" —á—Ç–æ–±—ã –Ω–∞—á–∞—Ç—å",
                msgYourTurn: "–í–∞—à —Ö–æ–¥ - –≤—ã–±–µ—Ä–∏—Ç–µ –ª—É–Ω–∫—É",
                msgComputerThinking: "–î—É–º–∞—é... [{n}]",
                msgWatchStones: "–ü–æ—Å–µ–≤ –∫–∞–º–Ω–µ–π...",
                msgExtraTurn: "–î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–π —Ö–æ–¥!",
                msgCapture: "–ó–∞—Ö–≤–∞—Ç!",
                msgTie: "–ù–∏—á—å—è!",
                msgHint: "–°–æ–≤–µ—Ç—É—é –ø–æ–π—Ç–∏ –∏–∑ –ª—É–Ω–∫–∏ {n}",
                // Varied end-game messages (from Pascal original)
                msgYouLose: [
                    "–ò–∑–≤–∏–Ω–∏—Ç–µ, –í—ã –ø—Ä–æ–∏–≥—Ä–∞–ª–∏...",
                    "–ù–µ –æ—Ç—á–∞–∏–≤–∞–π—Ç–µ—Å—å - –µ—â—ë –≤—ã–∏–≥—Ä–∞–µ—Ç–µ!",
                    "–°–ª–µ–¥—É—é—â–∏–π —Ä–∞–∑ –í–∞–º –¥–æ–ª–∂–Ω–æ –ø–æ–≤–µ–∑—Ç–∏.",
                    "–°–æ–≤–µ—Ç—É—é –ø–æ—Ç—Ä–µ–Ω–∏—Ä–æ–≤–∞—Ç—å—Å—è –≤ –Ω–æ–≤–∏—á–∫–∞—Ö.",
                    "–ò–Ω—Ç–µ–ª–ª–µ–∫—Ç –ø—Ä–æ—Ç–∏–≤ –º–∞—Å—Ç–µ—Ä—Å—Ç–≤–∞ - –±–µ—Å—Å–∏–ª–µ–Ω!"
                ],
                msgYouWin: [
                    "–°–ª–µ–¥—É—é—â–∏–π —Ä–∞–∑ –æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ –≤—ã–∏–≥—Ä–∞—é...",
                    "–ü—Ä–∏–º–∏—Ç–µ –º–æ–∏ –ø–æ–∑–¥—Ä–∞–≤–ª–µ–Ω–∏—è!",
                    "–ù–µ –ª—é–±–ª—é –ø—Ä–æ–∏–≥—Ä—ã–≤–∞—Ç—å, –Ω–æ –í–∞—à–∞ –≤–∑—è–ª–∞.",
                    "–ö–∞–∫ –∂–µ —ç—Ç–æ —è –ø—Ä–æ–∏–≥—Ä–∞–ª!",
                    "–ú–Ω–µ –∫–∞–∂–µ—Ç—Å—è, —á—Ç–æ –í—ã —Å–ª—É—á–∞–π–Ω–æ –≤—ã–∏–≥—Ä–∞–ª–∏."
                ],
                // Single move taunting messages
                msgOnlyOneMove: [
                    "–ù–µ —Å–æ–≤–µ—Ç—É—é —Ö–æ–¥–∏—Ç—å –∏–∑ –ª—É–Ω–∫–∏ {n}!",
                    "–•–æ—Ä–æ—à–æ –ø–æ–¥—É–º–∞–π—Ç–µ –∏–∑ –∫–∞–∫–æ–π –ª—É–Ω–∫–∏ –ø–æ–π—Ç–∏!",
                    "–ò–Ω—Ç–µ—Ä–µ—Å–Ω–æ, –∏–∑ –∫–∞–∫–æ–π –ª—É–Ω–∫–∏ –í—ã –ø–æ–π–¥—ë—Ç–µ?",
                    "–ö–∞–∫–æ–π –∂–µ –í—ã —Å–¥–µ–ª–∞–µ—Ç–µ —Ö–æ–¥?",
                    "–°–æ–≤–µ—Ç—É—é –ø–æ–π—Ç–∏ –∏–∑ –ª—É–Ω–∫–∏ {n}!"
                ],
                // Advice prompt
                msgWantAdvice: "–ñ–µ–ª–∞–µ—Ç–µ –ø–æ–ª—É—á–∏—Ç—å —Å–æ–≤–µ—Ç?",
                msgAdvice: "–°–æ–≤–µ—Ç—É—é —Å–¥–µ–ª–∞—Ç—å —Ö–æ–¥ –∏–∑ –ª—É–Ω–∫–∏ {n}"
            }
        };

        let currentLang = 'en';

        function setLanguage(lang) {
            currentLang = lang;
            localStorage.setItem('kalahLang', lang);

            // Update language button states
            document.getElementById('langEn').classList.toggle('active', lang === 'en');
            document.getElementById('langRu').classList.toggle('active', lang === 'ru');

            // Update all text elements
            const t = translations[lang];

            document.getElementById('title').textContent = t.title;
            document.getElementById('subtitle').textContent = t.subtitle;
            document.getElementById('labelPits').textContent = t.labelPits;
            document.getElementById('labelStones').textContent = t.labelStones;
            document.getElementById('labelLevel').textContent = t.labelLevel;
            document.getElementById('levelEasy').textContent = t.levelEasy;
            document.getElementById('levelMedium').textContent = t.levelMedium;
            document.getElementById('levelHard').textContent = t.levelHard;
            document.getElementById('levelWizard').textContent = t.levelWizard;
            document.getElementById('labelYouFirst').textContent = t.labelYouFirst;
            document.getElementById('newGameBtn').textContent = t.newGame;
            document.getElementById('computerLabel').textContent = t.computerLabel;
            document.getElementById('playerLabel').textContent = t.playerLabel;
            document.getElementById('speedLabel').textContent = t.speedLabel;
            document.getElementById('hintBtn').textContent = t.hintBtn;
            document.getElementById('undoBtn').textContent = t.undoBtn;
            document.getElementById('rulesBtn').textContent = t.rulesBtn;

            // Update page title
            document.title = lang === 'ru' ? '–°—É–ø–µ—Ä-–ö–∞–ª–∞—Ö' : 'Super-Kalah';

            // Update message if game not in progress
            if (!game.isAnimating) {
                updateMessage();
            }

            // Re-render board to update kalah labels
            if (game.playerPits.length > 0) {
                renderBoard();
            }
        }

        function t(key) {
            return translations[currentLang][key] || translations['en'][key] || key;
        }

        // Load saved language preference
        function loadLanguage() {
            const saved = localStorage.getItem('kalahLang');
            if (saved && translations[saved]) {
                setLanguage(saved);
            } else {
                // Try to detect browser language
                const browserLang = navigator.language || navigator.userLanguage;
                if (browserLang && browserLang.startsWith('ru')) {
                    setLanguage('ru');
                }
            }
        }

        // ===================
        // SOUND EFFECTS
        // ===================
        let audioContext = null;
        let soundEnabled = true;

        function initAudio() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }
        }

        function playTone(frequency, duration, type = 'sine') {
            if (!soundEnabled || !audioContext) return;
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            oscillator.frequency.value = frequency;
            oscillator.type = type;
            gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration);
            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + duration);
        }

        function playDropSound(pitIndex) {
            const baseFreq = 300 + (pitIndex || 0) * 50;
            playTone(baseFreq + Math.random() * 100, 0.15, 'sine');
        }

        function playPickupSound() {
            playTone(200, 0.1);
            setTimeout(() => playTone(250, 0.1), 50);
        }

        function playCapture() {
            playTone(600, 0.1);
            setTimeout(() => playTone(800, 0.1), 100);
            setTimeout(() => playTone(1000, 0.2), 200);
        }

        function playExtraTurn() {
            playTone(523, 0.1);
            setTimeout(() => playTone(659, 0.1), 100);
            setTimeout(() => playTone(784, 0.2), 200);
        }

        function playKalahDrop() {
            playTone(400, 0.15);
            setTimeout(() => playTone(600, 0.15), 80);
        }

        function playWin() {
            const notes = [523, 659, 784, 1047];
            notes.forEach((note, i) => {
                setTimeout(() => playTone(note, 0.3), i * 150);
            });
        }

        function playLose() {
            playTone(400, 0.2);
            setTimeout(() => playTone(350, 0.2), 200);
            setTimeout(() => playTone(300, 0.4), 400);
        }

        function toggleSound() {
            initAudio();
            soundEnabled = !soundEnabled;
            document.getElementById('soundBtn').innerHTML = soundEnabled ? '&#128266;' : '&#128263;';
        }

        // ===================
        // INPUT HELPERS
        // ===================
        function adjustNumber(inputId, delta) {
            const input = document.getElementById(inputId);
            const min = parseInt(input.min) || 1;
            const max = parseInt(input.max) || 10;
            let value = parseInt(input.value) || min;
            value = Math.max(min, Math.min(max, value + delta));
            input.value = value;
            playTone(300 + delta * 50, 0.05);
        }

        // ===================
        // VICTORY EFFECT
        // ===================
        function createConfetti() {
            const container = document.getElementById('confetti');
            container.innerHTML = '';
            // Natural, muted gold and amber tones
            const colors = ['#c9a961', '#b8956a', '#a08050', '#d4b896', '#8b7355', '#c4a060'];
            const shapes = ['‚óè', '‚óÜ', '‚ú¶'];

            for (let i = 0; i < 30; i++) {
                const piece = document.createElement('div');
                piece.className = 'confetti-piece';
                piece.textContent = shapes[Math.floor(Math.random() * shapes.length)];
                piece.style.left = Math.random() * 100 + 'vw';
                piece.style.color = colors[Math.floor(Math.random() * colors.length)];
                piece.style.fontSize = (Math.random() * 15 + 8) + 'px';
                piece.style.animationDelay = Math.random() * 0.5 + 's';
                container.appendChild(piece);
            }

            setTimeout(() => container.innerHTML = '', 3500);
        }

        // ===================
        // GAME STATE
        // ===================
        // Natural gemstone and mineral colors
        const stoneColors = ['#8B4513', '#2F4F4F', '#4A5D23', '#8B6914', '#5D3954', '#1E3A3A', '#6B4423', '#3D5C5C'];

        function getAnimationDelay() {
            const slider = document.getElementById('speedSlider');
            return 450 - parseInt(slider.value);
        }

        let game = {
            numPits: 6,
            numStones: 4,
            difficulty: 3,
            playerPits: [],
            computerPits: [],
            playerKalah: 0,
            computerKalah: 0,
            isPlayerTurn: true,
            gameOver: false,
            isAnimating: false,
            history: []
        };

        // Debug: validate total stone count is correct
        function validateStoneCount() {
            const expectedTotal = game.numPits * game.numStones * 2;
            const actualTotal = game.playerPits.reduce((a, b) => a + b, 0) +
                               game.computerPits.reduce((a, b) => a + b, 0) +
                               game.playerKalah + game.computerKalah;
            if (actualTotal !== expectedTotal) {
                console.error(`Stone count mismatch! Expected ${expectedTotal}, got ${actualTotal}`);
                console.error('State:', JSON.stringify({
                    playerPits: game.playerPits,
                    computerPits: game.computerPits,
                    playerKalah: game.playerKalah,
                    computerKalah: game.computerKalah
                }));
                return false;
            }
            return true;
        }

        const MoveStatus = {
            OK: 'ok',
            EXTRA_TURN: 'extraTurn',
            CAPTURE: 'capture',
            END_OF_GAME: 'endOfGame',
            EMPTY: 'empty',
            BAD_MOVE: 'badMove'
        };

        function setControlsEnabled(enabled) {
            document.getElementById('newGameBtn').disabled = !enabled;
            document.getElementById('hintBtn').disabled = !enabled;
            document.getElementById('undoBtn').disabled = !enabled;
        }

        // ===================
        // NEW GAME
        // ===================
        function newGame() {
            if (game.isAnimating) return;

            initAudio();
            game.numPits = parseInt(document.getElementById('numPits').value) || 6;
            game.numStones = parseInt(document.getElementById('numStones').value) || 4;
            game.difficulty = parseInt(document.getElementById('difficulty').value) || 3;
            game.isPlayerTurn = document.getElementById('playerFirst').checked;

            if (game.numPits < 3) game.numPits = 3;
            if (game.numPits > 10) game.numPits = 10;
            if (game.numStones < 1) game.numStones = 1;
            if (game.numStones > 10) game.numStones = 10;

            game.playerPits = new Array(game.numPits).fill(game.numStones);
            game.computerPits = new Array(game.numPits).fill(game.numStones);
            game.playerKalah = 0;
            game.computerKalah = 0;
            game.gameOver = false;
            game.isAnimating = false;
            game.history = [];

            playTone(523, 0.1);
            setTimeout(() => playTone(659, 0.1), 100);

            renderBoard();
            updateMessage();

            if (!game.isPlayerTurn) {
                setTimeout(computerMove, 800);
            }
        }

        // ===================
        // RENDERING
        // ===================
        function renderStones(count) {
            if (count === 0) return '';
            if (count > 12) return count;

            let html = '<div class="stones">';
            for (let i = 0; i < count; i++) {
                const color = stoneColors[i % stoneColors.length];
                html += `<span class="stone" style="background: ${color}; box-shadow: inset -2px -2px 4px rgba(0,0,0,0.3), 1px 1px 2px rgba(255,255,255,0.3);"></span>`;
            }
            html += '</div>';
            return html;
        }

        function getElementCenter(element) {
            const rect = element.getBoundingClientRect();
            return {
                x: rect.left + rect.width / 2,
                y: rect.top + rect.height / 2
            };
        }

        function createFlyingStone(fromEl, toEl, color, onComplete) {
            const from = getElementCenter(fromEl);
            const to = getElementCenter(toEl);

            const stone = document.createElement('div');
            stone.className = 'flying-stone';
            stone.style.background = color;
            stone.style.left = from.x - 9 + 'px';
            stone.style.top = from.y - 9 + 'px';

            document.body.appendChild(stone);

            const duration = 200;
            const startTime = performance.now();

            function animate(currentTime) {
                const elapsed = currentTime - startTime;
                const progress = Math.min(elapsed / duration, 1);
                const easeProgress = 1 - Math.pow(1 - progress, 2);

                // Straight line trajectory
                const x = from.x + (to.x - from.x) * easeProgress;
                const y = from.y + (to.y - from.y) * easeProgress;

                stone.style.left = x - 9 + 'px';
                stone.style.top = y - 9 + 'px';

                if (progress < 1) {
                    requestAnimationFrame(animate);
                } else {
                    stone.remove();
                    if (onComplete) onComplete();
                }
            }

            requestAnimationFrame(animate);
        }

        function renderBoard() {
            const board = document.getElementById('board');
            board.innerHTML = '';

            // Computer's kalah (left side)
            const computerKalah = document.createElement('div');
            computerKalah.className = 'kalah';
            computerKalah.id = 'computerKalah';
            computerKalah.innerHTML = game.computerKalah + `<span class="kalah-label">${t('kalahRobot')}</span>`;
            board.appendChild(computerKalah);

            // Pits container
            const pitsContainer = document.createElement('div');
            pitsContainer.className = 'pits-container';

            // Computer's pits (top row, reversed)
            const topRow = document.createElement('div');
            topRow.className = 'pits-row top-row';
            for (let i = game.numPits - 1; i >= 0; i--) {
                const pit = document.createElement('div');
                pit.className = 'pit disabled';
                pit.id = `computer-pit-${i}`;

                const count = game.computerPits[i];
                if (count <= 12 && count > 0) {
                    pit.innerHTML = renderStones(count);
                } else {
                    pit.textContent = count || '';
                }

                const label = document.createElement('span');
                label.className = 'pit-number';
                label.textContent = i + 1;
                pit.appendChild(label);

                topRow.appendChild(pit);
            }
            pitsContainer.appendChild(topRow);

            // Player's pits (bottom row)
            const bottomRow = document.createElement('div');
            bottomRow.className = 'pits-row bottom-row';
            for (let i = 0; i < game.numPits; i++) {
                const pit = document.createElement('div');
                pit.className = 'pit';
                pit.id = `player-pit-${i}`;

                const count = game.playerPits[i];
                if (count <= 12 && count > 0) {
                    pit.innerHTML = renderStones(count);
                } else {
                    pit.textContent = count || '';
                }

                pit.onclick = () => playerMove(i);

                if (game.playerPits[i] === 0 || !game.isPlayerTurn || game.gameOver || game.isAnimating) {
                    pit.classList.add('disabled');
                }

                const label = document.createElement('span');
                label.className = 'pit-number';
                label.textContent = i + 1;
                pit.appendChild(label);

                bottomRow.appendChild(pit);
            }
            pitsContainer.appendChild(bottomRow);

            board.appendChild(pitsContainer);

            // Player's kalah (right side)
            const playerKalah = document.createElement('div');
            playerKalah.className = 'kalah';
            playerKalah.id = 'playerKalah';
            playerKalah.innerHTML = game.playerKalah + `<span class="kalah-label">${t('kalahYou')}</span>`;
            board.appendChild(playerKalah);

            // Update labels
            document.getElementById('playerLabel').className =
                'player-banner player' + (game.isPlayerTurn && !game.gameOver ? ' active' : '');
            document.getElementById('computerLabel').className =
                'player-banner computer' + (!game.isPlayerTurn && !game.gameOver ? ' active' : '');
        }

        function updatePitDisplay(pitId, count) {
            const pit = document.getElementById(pitId);
            if (!pit) return;

            const label = pit.querySelector('.pit-number');
            const labelHtml = label ? label.outerHTML : '';

            if (count <= 12 && count > 0) {
                pit.innerHTML = renderStones(count) + labelHtml;
            } else {
                pit.innerHTML = (count || '') + labelHtml;
            }
        }

        function updateKalahDisplay(kalahId, count) {
            const kalah = document.getElementById(kalahId);
            if (!kalah) return;
            const label = kalahId === 'playerKalah' ? t('kalahYou') : t('kalahRobot');
            kalah.innerHTML = count + `<span class="kalah-label">${label}</span>`;
        }

        function getRandomEndMessage(isWin) {
            const messages = isWin ? translations[currentLang].msgYouWin : translations[currentLang].msgYouLose;
            return messages[Math.floor(Math.random() * messages.length)];
        }

        function updateMessage(thinkingPit) {
            const msg = document.getElementById('message');
            if (game.gameOver) {
                msg.className = 'message game-over';
                const playerTotal = game.playerKalah;
                const computerTotal = game.computerKalah;
                if (playerTotal > computerTotal) {
                    msg.textContent = `${getRandomEndMessage(true)} ${playerTotal} - ${computerTotal}`;
                    createConfetti();
                    playWin();
                } else if (computerTotal > playerTotal) {
                    msg.textContent = `${getRandomEndMessage(false)} ${computerTotal} - ${playerTotal}`;
                    playLose();
                } else {
                    msg.textContent = `${t('msgTie')} ${playerTotal} - ${computerTotal}`;
                }
            } else if (game.isAnimating) {
                msg.className = 'message computer-turn';
                msg.textContent = t('msgWatchStones');
            } else if (game.isPlayerTurn) {
                msg.className = 'message your-turn';
                msg.textContent = t('msgYourTurn');
            } else {
                msg.className = 'message computer-turn';
                const thinkingMsg = t('msgComputerThinking').replace('{n}', thinkingPit !== undefined ? thinkingPit : '');
                msg.textContent = thinkingMsg;
            }
        }

        // ===================
        // GAME LOGIC
        // ===================
        function saveState() {
            game.history.push({
                playerPits: [...game.playerPits],
                computerPits: [...game.computerPits],
                playerKalah: game.playerKalah,
                computerKalah: game.computerKalah,
                isPlayerTurn: game.isPlayerTurn,
                gameOver: game.gameOver
            });
        }

        function undoMove() {
            if (game.history.length === 0 || game.isAnimating) return;

            initAudio();
            playTone(300, 0.1);

            const state = game.history.pop();
            game.playerPits = state.playerPits;
            game.computerPits = state.computerPits;
            game.playerKalah = state.playerKalah;
            game.computerKalah = state.computerKalah;
            game.isPlayerTurn = state.isPlayerTurn;
            game.gameOver = state.gameOver;

            renderBoard();
            updateMessage();
        }

        function executeMove(playerPits, computerPits, playerKalah, computerKalah, pitIndex, isPlayer) {
            const myPits = isPlayer ? playerPits : computerPits;
            const opPits = isPlayer ? computerPits : playerPits;
            let myKalah = isPlayer ? playerKalah : computerKalah;
            let opKalah = isPlayer ? computerKalah : playerKalah;
            const numPits = myPits.length;

            if (pitIndex < 0 || pitIndex >= numPits) {
                return { status: MoveStatus.BAD_MOVE, playerKalah, computerKalah };
            }

            let stones = myPits[pitIndex];
            if (stones === 0) {
                return { status: MoveStatus.EMPTY, playerKalah, computerKalah };
            }

            myPits[pitIndex] = 0;
            let status = MoveStatus.OK;
            let currentIndex = pitIndex;
            let onMySide = true;
            let lastIndex = -1;
            let lastOnMySide = true;

            while (stones > 0) {
                currentIndex++;

                if (onMySide) {
                    if (currentIndex < numPits) {
                        myPits[currentIndex]++;
                        stones--;
                        lastIndex = currentIndex;
                        lastOnMySide = true;
                    } else if (currentIndex === numPits) {
                        myKalah++;
                        stones--;
                        if (stones === 0) {
                            status = MoveStatus.EXTRA_TURN;
                        }
                        onMySide = false;
                        currentIndex = -1;
                        lastIndex = -1;
                    }
                } else {
                    if (currentIndex < numPits) {
                        opPits[currentIndex]++;
                        stones--;
                        lastIndex = currentIndex;
                        lastOnMySide = false;
                    } else {
                        onMySide = true;
                        currentIndex = -1;
                    }
                }
            }

            if (lastOnMySide && lastIndex >= 0 && lastIndex < numPits && myPits[lastIndex] === 1) {
                const oppositeIndex = numPits - 1 - lastIndex;
                if (opPits[oppositeIndex] > 0) {
                    myKalah += myPits[lastIndex] + opPits[oppositeIndex];
                    myPits[lastIndex] = 0;
                    opPits[oppositeIndex] = 0;
                    status = MoveStatus.CAPTURE;
                }
            }

            if (isPlayer) {
                playerKalah = myKalah;
                computerKalah = opKalah;
            } else {
                computerKalah = myKalah;
                playerKalah = opKalah;
            }

            const myEmpty = myPits.every(p => p === 0);
            const opEmpty = opPits.every(p => p === 0);

            if (myEmpty || opEmpty) {
                if (myEmpty) {
                    const remaining = opPits.reduce((a, b) => a + b, 0);
                    if (isPlayer) {
                        computerKalah += remaining;
                    } else {
                        playerKalah += remaining;
                    }
                    opPits.fill(0);
                } else {
                    const remaining = myPits.reduce((a, b) => a + b, 0);
                    if (isPlayer) {
                        playerKalah += remaining;
                    } else {
                        computerKalah += remaining;
                    }
                    myPits.fill(0);
                }
                status = MoveStatus.END_OF_GAME;
            }

            return { status, playerKalah, computerKalah };
        }

        // ===================
        // ANIMATED MOVE
        // ===================

        // Compute move plan without modifying state - returns sequence of animations
        function computeMovePlan(playerPits, computerPits, playerKalah, computerKalah, pitIndex, isPlayer) {
            const myPits = isPlayer ? [...playerPits] : [...computerPits];
            const opPits = isPlayer ? [...computerPits] : [...playerPits];
            let myKalah = isPlayer ? playerKalah : computerKalah;
            const numPits = myPits.length;

            const plan = {
                moves: [],  // Array of {from: {type, index}, to: {type, index}}
                captures: null,  // {myPitIndex, opPitIndex, myStones, opStones}
                endGame: null,  // {collector: 'player'|'computer', remaining: [{pitIndex, count}]}
                finalState: {
                    playerPits: [...playerPits],
                    computerPits: [...computerPits],
                    playerKalah: playerKalah,
                    computerKalah: computerKalah
                },
                status: MoveStatus.OK
            };

            let stones = myPits[pitIndex];
            if (stones === 0) {
                plan.status = MoveStatus.EMPTY;
                return plan;
            }

            myPits[pitIndex] = 0;
            let currentIndex = pitIndex;
            let onMySide = true;
            let lastIndex = -1;
            let lastOnMySide = true;

            while (stones > 0) {
                currentIndex++;

                if (onMySide) {
                    if (currentIndex < numPits) {
                        plan.moves.push({
                            from: {type: isPlayer ? 'player' : 'computer', index: pitIndex},
                            to: {type: isPlayer ? 'player' : 'computer', index: currentIndex}
                        });
                        myPits[currentIndex]++;
                        stones--;
                        lastIndex = currentIndex;
                        lastOnMySide = true;
                    } else if (currentIndex === numPits) {
                        plan.moves.push({
                            from: {type: isPlayer ? 'player' : 'computer', index: pitIndex},
                            to: {type: 'kalah', owner: isPlayer ? 'player' : 'computer'}
                        });
                        myKalah++;
                        stones--;
                        if (stones === 0) {
                            plan.status = MoveStatus.EXTRA_TURN;
                        }
                        onMySide = false;
                        currentIndex = -1;
                        lastIndex = -1;
                    }
                } else {
                    if (currentIndex < numPits) {
                        plan.moves.push({
                            from: {type: isPlayer ? 'player' : 'computer', index: pitIndex},
                            to: {type: isPlayer ? 'computer' : 'player', index: currentIndex}
                        });
                        opPits[currentIndex]++;
                        stones--;
                        lastIndex = currentIndex;
                        lastOnMySide = false;
                    } else {
                        onMySide = true;
                        currentIndex = -1;
                    }
                }
            }

            // Check for capture
            if (lastOnMySide && lastIndex >= 0 && lastIndex < numPits && myPits[lastIndex] === 1) {
                const oppositeIndex = numPits - 1 - lastIndex;
                if (opPits[oppositeIndex] > 0) {
                    plan.captures = {
                        myPitIndex: lastIndex,
                        opPitIndex: oppositeIndex,
                        myStones: myPits[lastIndex],
                        opStones: opPits[oppositeIndex]
                    };
                    myKalah += myPits[lastIndex] + opPits[oppositeIndex];
                    myPits[lastIndex] = 0;
                    opPits[oppositeIndex] = 0;
                    plan.status = MoveStatus.CAPTURE;
                }
            }

            // Update final state
            if (isPlayer) {
                plan.finalState.playerPits = myPits;
                plan.finalState.computerPits = opPits;
                plan.finalState.playerKalah = myKalah;
            } else {
                plan.finalState.computerPits = myPits;
                plan.finalState.playerPits = opPits;
                plan.finalState.computerKalah = myKalah;
            }

            // Check for game end
            const myEmpty = myPits.every(p => p === 0);
            const opEmpty = opPits.every(p => p === 0);

            if (myEmpty || opEmpty) {
                if (myEmpty) {
                    const remaining = opPits.reduce((a, b) => a + b, 0);
                    if (remaining > 0) {
                        plan.endGame = {
                            collector: isPlayer ? 'computer' : 'player',
                            pits: []
                        };
                        for (let i = 0; i < numPits; i++) {
                            if (opPits[i] > 0) {
                                plan.endGame.pits.push({index: i, count: opPits[i]});
                            }
                        }
                        if (isPlayer) {
                            plan.finalState.computerKalah += remaining;
                        } else {
                            plan.finalState.playerKalah += remaining;
                        }
                    }
                    plan.finalState.computerPits = new Array(numPits).fill(0);
                    plan.finalState.playerPits = isPlayer ? myPits : new Array(numPits).fill(0);
                } else {
                    const remaining = myPits.reduce((a, b) => a + b, 0);
                    if (remaining > 0) {
                        plan.endGame = {
                            collector: isPlayer ? 'player' : 'computer',
                            pits: []
                        };
                        for (let i = 0; i < numPits; i++) {
                            if (myPits[i] > 0) {
                                plan.endGame.pits.push({index: i, count: myPits[i]});
                            }
                        }
                        if (isPlayer) {
                            plan.finalState.playerKalah += remaining;
                        } else {
                            plan.finalState.computerKalah += remaining;
                        }
                    }
                    plan.finalState.playerPits = isPlayer ? new Array(numPits).fill(0) : opPits;
                    plan.finalState.computerPits = isPlayer ? opPits : new Array(numPits).fill(0);
                }
                plan.status = MoveStatus.END_OF_GAME;
            }

            return plan;
        }

        function getStonePosition(pitElement, stoneIndex) {
            // Get position of a specific stone in the pit, or pit center if not found
            const stones = pitElement.querySelectorAll('.stone');
            let targetEl = pitElement;
            if (stones.length > stoneIndex && stoneIndex >= 0) {
                targetEl = stones[stoneIndex];
            }
            const rect = targetEl.getBoundingClientRect();
            return {
                x: rect.left + rect.width / 2,
                y: rect.top + rect.height / 2
            };
        }

        async function executeMoveAnimated(pitIndex, isPlayer) {
            const delay = getAnimationDelay();
            const numPits = game.numPits;

            // Compute the move plan FIRST using pure logic
            const plan = computeMovePlan(
                game.playerPits, game.computerPits,
                game.playerKalah, game.computerKalah,
                pitIndex, isPlayer
            );

            if (plan.status === MoveStatus.EMPTY) {
                return { status: MoveStatus.EMPTY };
            }

            const myPitPrefix = isPlayer ? 'player-pit-' : 'computer-pit-';
            const opPitPrefix = isPlayer ? 'computer-pit-' : 'player-pit-';
            const sourcePit = document.getElementById(myPitPrefix + pitIndex);

            // Create a visual copy of current stone count for animation
            let visualSourceStones = isPlayer ? game.playerPits[pitIndex] : game.computerPits[pitIndex];

            // Show pickup animation
            sourcePit.classList.add('emptying');
            playPickupSound();

            // Animate each stone move from the plan
            for (let i = 0; i < plan.moves.length; i++) {
                const move = plan.moves[i];
                const color = stoneColors[i % stoneColors.length];

                // Get source position from current visual state
                const stonePos = getStonePosition(sourcePit, Math.max(0, visualSourceStones - 1));

                // Visually decrement source and update display
                visualSourceStones--;
                updatePitDisplay(myPitPrefix + pitIndex, Math.max(0, visualSourceStones));

                // Determine target element
                let targetEl;
                if (move.to.type === 'kalah') {
                    targetEl = document.getElementById(move.to.owner === 'player' ? 'playerKalah' : 'computerKalah');
                } else {
                    const prefix = move.to.type === 'player' ? 'player-pit-' : 'computer-pit-';
                    targetEl = document.getElementById(prefix + move.to.index);
                }

                // Animate the stone
                await animateStoneFromPosition(stonePos, targetEl, color);

                // Update visual display of destination (incremental for visual feedback)
                if (move.to.type === 'kalah') {
                    // Show incremental kalah count during animation
                    const kalahId = move.to.owner === 'player' ? 'playerKalah' : 'computerKalah';
                    const currentVisual = move.to.owner === 'player'
                        ? game.playerKalah + plan.moves.slice(0, i + 1).filter(m => m.to.type === 'kalah' && m.to.owner === 'player').length
                        : game.computerKalah + plan.moves.slice(0, i + 1).filter(m => m.to.type === 'kalah' && m.to.owner === 'computer').length;
                    updateKalahDisplay(kalahId, currentVisual);
                    playKalahDrop();
                } else {
                    // Count how many stones have landed in this pit so far
                    const prefix = move.to.type === 'player' ? 'player-pit-' : 'computer-pit-';
                    const basePits = move.to.type === 'player' ? game.playerPits : game.computerPits;
                    const landedCount = plan.moves.slice(0, i + 1).filter(m =>
                        m.to.type === move.to.type && m.to.index === move.to.index
                    ).length;
                    updatePitDisplay(prefix + move.to.index, basePits[move.to.index] + landedCount);
                    playDropSound(move.to.index);
                }

                targetEl.classList.add('receiving');
                setTimeout(() => targetEl.classList.remove('receiving'), 300);

                await sleep(delay);
            }

            sourcePit.classList.remove('emptying');

            // Handle capture animation
            if (plan.captures) {
                await sleep(delay);

                const msg = document.getElementById('message');
                msg.textContent = t('msgCapture');
                playCapture();

                const myPit = document.getElementById(myPitPrefix + plan.captures.myPitIndex);
                const opPit = document.getElementById(opPitPrefix + plan.captures.opPitIndex);
                const myKalahEl = document.getElementById(isPlayer ? 'playerKalah' : 'computerKalah');
                const myKalahId = isPlayer ? 'playerKalah' : 'computerKalah';

                // Track visual kalah count during capture
                // Start with kalah count after the normal sowing (before capture)
                const kalahAfterSowing = isPlayer
                    ? game.playerKalah + plan.moves.filter(m => m.to.type === 'kalah' && m.to.owner === 'player').length
                    : game.computerKalah + plan.moves.filter(m => m.to.type === 'kalah' && m.to.owner === 'computer').length;
                let visualKalahCount = kalahAfterSowing;

                // Capture: first take the stone from my pit
                const myStonePos = getStonePosition(myPit, 0);
                const myColor = stoneColors[0];
                updatePitDisplay(myPitPrefix + plan.captures.myPitIndex, 0);
                await animateStoneFromPosition(myStonePos, myKalahEl, myColor);
                visualKalahCount++;
                updateKalahDisplay(myKalahId, visualKalahCount);
                playKalahDrop();

                // Then take all stones from opponent's pit one by one
                for (let i = plan.captures.opStones - 1; i >= 0; i--) {
                    const stonePos = getStonePosition(opPit, i);
                    const color = stoneColors[(plan.captures.opStones - i) % stoneColors.length];
                    updatePitDisplay(opPitPrefix + plan.captures.opPitIndex, i);
                    await animateStoneFromPosition(stonePos, myKalahEl, color);
                    visualKalahCount++;
                    updateKalahDisplay(myKalahId, visualKalahCount);
                    playKalahDrop();
                    await sleep(delay / 3);
                }

                myKalahEl.classList.add('receiving');
                setTimeout(() => myKalahEl.classList.remove('receiving'), 300);
            }

            // Handle end game collection animation
            if (plan.endGame) {
                await sleep(delay);

                const collectorKalahEl = document.getElementById(plan.endGame.collector === 'player' ? 'playerKalah' : 'computerKalah');
                const collectorKalahId = plan.endGame.collector === 'player' ? 'playerKalah' : 'computerKalah';
                const pitPrefix = plan.endGame.collector === 'player' ? 'player-pit-' : 'computer-pit-';

                // Calculate visual kalah count at this point (after sowing and possible capture)
                let visualKalahCount;
                if (plan.endGame.collector === 'player') {
                    visualKalahCount = game.playerKalah + plan.moves.filter(m => m.to.type === 'kalah' && m.to.owner === 'player').length;
                    if (plan.captures && isPlayer) {
                        visualKalahCount += plan.captures.myStones + plan.captures.opStones;
                    }
                } else {
                    visualKalahCount = game.computerKalah + plan.moves.filter(m => m.to.type === 'kalah' && m.to.owner === 'computer').length;
                    if (plan.captures && !isPlayer) {
                        visualKalahCount += plan.captures.myStones + plan.captures.opStones;
                    }
                }

                for (const pitInfo of plan.endGame.pits) {
                    const fromPit = document.getElementById(pitPrefix + pitInfo.index);
                    for (let i = pitInfo.count - 1; i >= 0; i--) {
                        const stonePos = getStonePosition(fromPit, i);
                        const color = stoneColors[(pitInfo.count - i) % stoneColors.length];
                        updatePitDisplay(pitPrefix + pitInfo.index, i);
                        await animateStoneFromPosition(stonePos, collectorKalahEl, color);
                        visualKalahCount++;
                        updateKalahDisplay(collectorKalahId, visualKalahCount);
                        playKalahDrop();
                        await sleep(delay / 4);
                    }
                }
            }

            // Apply final state atomically - this is the source of truth
            game.playerPits = plan.finalState.playerPits;
            game.computerPits = plan.finalState.computerPits;
            game.playerKalah = plan.finalState.playerKalah;
            game.computerKalah = plan.finalState.computerKalah;

            return { status: plan.status };
        }

        function animateStoneFromPosition(fromPos, toEl, color) {
            return new Promise(resolve => {
                const toRect = toEl.getBoundingClientRect();
                const to = {
                    x: toRect.left + toRect.width / 2,
                    y: toRect.top + toRect.height / 2
                };

                const stone = document.createElement('div');
                stone.className = 'flying-stone';
                stone.style.background = color;
                stone.style.left = fromPos.x - 9 + 'px';
                stone.style.top = fromPos.y - 9 + 'px';

                document.body.appendChild(stone);

                const duration = 200;
                const startTime = performance.now();

                function animate(currentTime) {
                    const elapsed = currentTime - startTime;
                    const progress = Math.min(elapsed / duration, 1);
                    // Simple ease-out for smooth deceleration
                    const easeProgress = 1 - Math.pow(1 - progress, 2);

                    // Straight line trajectory
                    const x = fromPos.x + (to.x - fromPos.x) * easeProgress;
                    const y = fromPos.y + (to.y - fromPos.y) * easeProgress;

                    stone.style.left = x - 9 + 'px';
                    stone.style.top = y - 9 + 'px';

                    if (progress < 1) {
                        requestAnimationFrame(animate);
                    } else {
                        stone.remove();
                        resolve();
                    }
                }

                requestAnimationFrame(animate);
            });
        }

        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        // ===================
        // PLAYER MOVE
        // ===================
        async function playerMove(pitIndex) {
            if (!game.isPlayerTurn || game.gameOver || game.playerPits[pitIndex] === 0 || game.isAnimating) {
                return;
            }

            initAudio();
            saveState();
            game.isAnimating = true;
            setControlsEnabled(false);
            updateMessage();
            renderBoard();

            const result = await executeMoveAnimated(pitIndex, true);

            game.isAnimating = false;
            setControlsEnabled(true);

            if (result.status === MoveStatus.END_OF_GAME) {
                game.gameOver = true;
            } else if (result.status === MoveStatus.EXTRA_TURN) {
                const msg = document.getElementById('message');
                msg.textContent = t('msgExtraTurn');
                playExtraTurn();
            } else {
                game.isPlayerTurn = false;
            }

            renderBoard();
            validateStoneCount();  // Debug assertion

            if (result.status !== MoveStatus.EXTRA_TURN) {
                updateMessage();
            }

            if (!game.isPlayerTurn && !game.gameOver) {
                setTimeout(computerMove, 500);
            }
        }

        // ===================
        // AI
        // ===================
        function minimax(playerPits, computerPits, playerKalah, computerKalah, depth, isMaximizing, alpha, beta) {
            const playerEmpty = playerPits.every(p => p === 0);
            const computerEmpty = computerPits.every(p => p === 0);

            if (playerEmpty || computerEmpty || depth === 0) {
                let pKalah = playerKalah;
                let cKalah = computerKalah;
                if (playerEmpty) {
                    cKalah += computerPits.reduce((a, b) => a + b, 0);
                } else if (computerEmpty) {
                    pKalah += playerPits.reduce((a, b) => a + b, 0);
                }
                return cKalah - pKalah;
            }

            const pits = isMaximizing ? computerPits : playerPits;

            if (isMaximizing) {
                let maxEval = -Infinity;
                for (let i = 0; i < pits.length; i++) {
                    if (pits[i] === 0) continue;

                    const newPlayerPits = [...playerPits];
                    const newComputerPits = [...computerPits];

                    const result = executeMove(
                        newPlayerPits, newComputerPits,
                        playerKalah, computerKalah,
                        i, false
                    );

                    const extraTurn = result.status === MoveStatus.EXTRA_TURN;
                    const gameEnd = result.status === MoveStatus.END_OF_GAME;

                    let evalScore;
                    if (gameEnd) {
                        evalScore = result.computerKalah - result.playerKalah;
                    } else {
                        evalScore = minimax(
                            newPlayerPits, newComputerPits,
                            result.playerKalah, result.computerKalah,
                            extraTurn ? depth : depth - 1,
                            extraTurn,
                            alpha, beta
                        );
                    }

                    maxEval = Math.max(maxEval, evalScore);
                    alpha = Math.max(alpha, evalScore);
                    if (beta <= alpha) break;
                }
                return maxEval;
            } else {
                let minEval = Infinity;
                for (let i = 0; i < pits.length; i++) {
                    if (pits[i] === 0) continue;

                    const newPlayerPits = [...playerPits];
                    const newComputerPits = [...computerPits];

                    const result = executeMove(
                        newPlayerPits, newComputerPits,
                        playerKalah, computerKalah,
                        i, true
                    );

                    const extraTurn = result.status === MoveStatus.EXTRA_TURN;
                    const gameEnd = result.status === MoveStatus.END_OF_GAME;

                    let evalScore;
                    if (gameEnd) {
                        evalScore = result.computerKalah - result.playerKalah;
                    } else {
                        evalScore = minimax(
                            newPlayerPits, newComputerPits,
                            result.playerKalah, result.computerKalah,
                            extraTurn ? depth : depth - 1,
                            !extraTurn,
                            alpha, beta
                        );
                    }

                    minEval = Math.min(minEval, evalScore);
                    beta = Math.min(beta, evalScore);
                    if (beta <= alpha) break;
                }
                return minEval;
            }
        }

        function findBestMove() {
            const depth = game.difficulty + 2;
            let bestMove = -1;
            let bestScore = -Infinity;

            for (let i = 0; i < game.numPits; i++) {
                if (game.computerPits[i] === 0) continue;

                const newPlayerPits = [...game.playerPits];
                const newComputerPits = [...game.computerPits];

                const result = executeMove(
                    newPlayerPits, newComputerPits,
                    game.playerKalah, game.computerKalah,
                    i, false
                );

                const extraTurn = result.status === MoveStatus.EXTRA_TURN;
                const gameEnd = result.status === MoveStatus.END_OF_GAME;

                let score;
                if (gameEnd) {
                    score = result.computerKalah - result.playerKalah;
                } else {
                    score = minimax(
                        newPlayerPits, newComputerPits,
                        result.playerKalah, result.computerKalah,
                        extraTurn ? depth : depth - 1,
                        extraTurn,
                        -Infinity, Infinity
                    );
                }

                if (extraTurn) score += 0.1;

                if (score > bestScore) {
                    bestScore = score;
                    bestMove = i;
                }
            }

            return bestMove;
        }

        async function computerMove() {
            if (game.isPlayerTurn || game.gameOver || game.isAnimating) return;

            saveState();
            game.isAnimating = true;
            setControlsEnabled(false);
            updateMessage();

            const moveIndex = findBestMove();
            if (moveIndex === -1) {
                game.gameOver = true;
                game.isAnimating = false;
                setControlsEnabled(true);
                renderBoard();
                updateMessage();
                return;
            }

            const result = await executeMoveAnimated(moveIndex, false);

            game.isAnimating = false;
            setControlsEnabled(true);

            if (result.status === MoveStatus.END_OF_GAME) {
                game.gameOver = true;
            } else if (result.status === MoveStatus.EXTRA_TURN) {
                playExtraTurn();
                renderBoard();
                validateStoneCount();  // Debug assertion
                updateMessage();
                setTimeout(computerMove, 500);
                return;
            } else {
                game.isPlayerTurn = true;
            }

            renderBoard();
            validateStoneCount();  // Debug assertion
            updateMessage();
        }

        // ===================
        // HINT
        // ===================
        function getHint() {
            if (!game.isPlayerTurn || game.gameOver || game.isAnimating) return;

            initAudio();
            playTone(600, 0.1);
            setTimeout(() => playTone(800, 0.1), 100);

            const depth = game.difficulty + 2;
            let bestMove = -1;
            let bestScore = -Infinity;

            for (let i = 0; i < game.numPits; i++) {
                if (game.playerPits[i] === 0) continue;

                const newPlayerPits = [...game.playerPits];
                const newComputerPits = [...game.computerPits];

                const result = executeMove(
                    newPlayerPits, newComputerPits,
                    game.playerKalah, game.computerKalah,
                    i, true
                );

                const extraTurn = result.status === MoveStatus.EXTRA_TURN;
                const gameEnd = result.status === MoveStatus.END_OF_GAME;

                let score;
                if (gameEnd) {
                    score = result.playerKalah - result.computerKalah;
                } else {
                    score = -minimax(
                        newPlayerPits, newComputerPits,
                        result.playerKalah, result.computerKalah,
                        extraTurn ? depth : depth - 1,
                        !extraTurn,
                        -Infinity, Infinity
                    );
                }

                if (extraTurn) score += 0.1;

                if (score > bestScore) {
                    bestScore = score;
                    bestMove = i;
                }
            }

            if (bestMove >= 0) {
                const pit = document.getElementById(`player-pit-${bestMove}`);
                pit.classList.add('highlight');
                document.getElementById('message').textContent = t('msgAdvice').replace('{n}', bestMove + 1);
                setTimeout(() => {
                    pit.classList.remove('highlight');
                    updateMessage();
                }, 1500);
            }
        }

        // ===================
        // INIT
        // ===================
        const style = document.createElement('style');
        style.textContent = `
            @keyframes pop {
                0% { transform: scale(0); opacity: 0; }
                50% { transform: scale(1.2); }
                100% { transform: scale(1); opacity: 1; }
            }
        `;
        document.head.appendChild(style);

        // ===================
        // RULES MODAL
        // ===================
        let currentRulesTab = 0;

        function getBoardDiagramSVG(isRu) {
            const oppLabel = isRu ? '–°–û–ü' : 'OPP';
            const youLabel = isRu ? '–í–´' : 'YOU';
            return `
                <svg viewBox="0 0 400 180" xmlns="http://www.w3.org/2000/svg">
                <rect x="10" y="10" width="380" height="160" rx="12" fill="#4a3c2a" stroke="#6b5a45" stroke-width="2"/>

                <rect x="20" y="25" width="40" height="130" rx="20" fill="#3d3225" stroke="#5a4a35" stroke-width="1.5"/>
                <text x="40" y="95" text-anchor="middle" fill="#d4b896" font-size="10" font-family="Cinzel">${oppLabel}</text>

                <rect x="340" y="25" width="40" height="130" rx="20" fill="#3d3225" stroke="#5a4a35" stroke-width="1.5"/>
                <text x="360" y="95" text-anchor="middle" fill="#b0d0c0" font-size="10" font-family="Cinzel">${youLabel}</text>

                <g fill="#3d3225" stroke="#5a4a35" stroke-width="1.5">
                <circle cx="100" cy="55" r="22"/><text x="100" y="60" text-anchor="middle" fill="#d4b896" font-size="14">6</text>
                <circle cx="150" cy="55" r="22"/><text x="150" y="60" text-anchor="middle" fill="#d4b896" font-size="14">6</text>
                <circle cx="200" cy="55" r="22"/><text x="200" y="60" text-anchor="middle" fill="#d4b896" font-size="14">6</text>
                <circle cx="250" cy="55" r="22"/><text x="250" y="60" text-anchor="middle" fill="#d4b896" font-size="14">6</text>
                <circle cx="300" cy="55" r="22"/><text x="300" y="60" text-anchor="middle" fill="#d4b896" font-size="14">6</text>
                </g>

                <g fill="#3d3225" stroke="#4a8060" stroke-width="1.5">
                <circle cx="100" cy="125" r="22"/><text x="100" y="130" text-anchor="middle" fill="#b0d0c0" font-size="14">6</text>
                <circle cx="150" cy="125" r="22"/><text x="150" y="130" text-anchor="middle" fill="#b0d0c0" font-size="14">6</text>
                <circle cx="200" cy="125" r="22"/><text x="200" y="130" text-anchor="middle" fill="#b0d0c0" font-size="14">6</text>
                <circle cx="250" cy="125" r="22"/><text x="250" y="130" text-anchor="middle" fill="#b0d0c0" font-size="14">6</text>
                <circle cx="300" cy="125" r="22"/><text x="300" y="130" text-anchor="middle" fill="#b0d0c0" font-size="14">6</text>
                </g>

                <path d="M 100 135 L 300 135 C 360 135 360 45 300 45 L 100 45 C 40 45 40 135 90 135"
                fill="none" stroke="#c9a961" stroke-width="2.5" stroke-dasharray="6,4" opacity="0.7" stroke-linecap="round"/>

                <polygon points="90,135 82,131 82,139" fill="#c9a961" transform="rotate(10, 90, 135)"/>
                </svg>
                `;
        }

        function getStepDiagramSVG() {
            return `
                <svg viewBox="0 0 400 180" xmlns="http://www.w3.org/2000/svg">
                    <rect x="10" y="20" width="380" height="120" rx="12" fill="#4a3c2a" stroke="#6b5a45" stroke-width="2"/>

                    <g fill="#3d3225" stroke="#5a4a35" stroke-width="1.5">
                        <circle cx="80" cy="90" r="25" stroke="#c9a961" stroke-dasharray="4,2"/>
                        <circle cx="160" cy="90" r="25"/>
                        <circle cx="240" cy="90" r="25"/>
                        <circle cx="320" cy="90" r="25"/>
                    </g>

                    <path d="M 80 65 Q 120 20 160 60 Q 200 20 240 60 Q 280 20 320 60" 
                          fill="none" stroke="#c9a961" stroke-width="2" stroke-dasharray="5,5" opacity="0.6"/>

                    <circle cx="110" cy="40" r="6" fill="#f0d5a0" />
                    <circle cx="190" cy="40" r="6" fill="#f0d5a0" />
                    <circle cx="270" cy="40" r="6" fill="#f0d5a0" />

                    <g fill="#d4b896">
                        <circle cx="160" cy="90" r="5"/>
                        <circle cx="240" cy="90" r="5"/>
                        <circle cx="320" cy="90" r="5"/>
                    </g>

                    <g transform="translate(65, 50)">
                       <path d="M 5 10 Q 15 -10 30 10 L 25 25 L 10 25 Z" fill="#d4b896" opacity="0.9"/>
                       <text x="17" y="20" text-anchor="middle" fill="#4a3c2a" font-size="8" font-weight="bold">3</text>
                    </g>
                </svg>
            `;
        }

        function getCaptureDiagramSVG(isRu) {
            const oppLabel = isRu ? '–°–û–ü' : 'OPP';
            const youLabel = isRu ? '–í–´' : 'YOU';
            const captureLabel = isRu ? '–ó–∞—Ö–≤–∞—Ç!' : 'Capture!';
            return `
                <svg viewBox="0 0 400 180" xmlns="http://www.w3.org/2000/svg">
                <defs>
                <marker id="arrowhead" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
                <polygon points="0 0, 10 3.5, 0 7" fill="#c9a961" />
                </marker>
                </defs>

                <rect x="10" y="10" width="380" height="160" rx="12" fill="#4a3c2a" stroke="#6b5a45" stroke-width="2"/>

                <rect x="20" y="25" width="40" height="130" rx="20" fill="#3d3225" stroke="#5a4a35" stroke-width="1.5"/>
                <text x="40" y="95" text-anchor="middle" fill="#d4b896" font-size="10" font-family="Cinzel">${oppLabel}</text>

                <rect x="340" y="25" width="40" height="130" rx="20" fill="#3d3225" stroke="#c9a961" stroke-width="2.5"/>
                <text x="360" y="85" text-anchor="middle" fill="#c9a961" font-size="22" font-weight="bold">+5</text>
                <text x="360" y="105" text-anchor="middle" fill="#b0d0c0" font-size="10" font-family="Cinzel">${youLabel}</text>

                <g fill="#3d3225" stroke="#5a4a35" stroke-width="1.5">
                <circle cx="100" cy="55" r="22"/><text x="100" y="60" text-anchor="middle" fill="#d4b896" font-size="14">3</text>
                <circle cx="150" cy="55" r="22"/><text x="150" y="60" text-anchor="middle" fill="#d4b896" font-size="14">5</text>
                </g>

                <circle cx="200" cy="55" r="22" fill="#3d3225" stroke="#c9a961" stroke-width="2.5"/>
                <text x="200" y="60" text-anchor="middle" fill="#c9a961" font-size="14" font-weight="bold">4</text>

                <g fill="#3d3225" stroke="#5a4a35" stroke-width="1.5">
                <circle cx="250" cy="55" r="22"/><text x="250" y="60" text-anchor="middle" fill="#d4b896" font-size="14">2</text>
                <circle cx="300" cy="55" r="22"/><text x="300" y="60" text-anchor="middle" fill="#d4b896" font-size="14">1</text>
                </g>

                <g fill="#3d3225" stroke="#4a8060" stroke-width="1.5">
                <circle cx="100" cy="125" r="22"/><text x="100" y="130" text-anchor="middle" fill="#b0d0c0" font-size="14">0</text>
                <circle cx="150" cy="125" r="22"/><text x="150" y="130" text-anchor="middle" fill="#b0d0c0" font-size="14">3</text>
                </g>

                <circle cx="200" cy="125" r="22" fill="#3d3225" stroke="#c9a961" stroke-width="2.5"/>
                <text x="200" y="130" text-anchor="middle" fill="#c9a961" font-size="14" font-weight="bold">1</text>

                <g fill="#3d3225" stroke="#4a8060" stroke-width="1.5">
                <circle cx="250" cy="125" r="22"/><text x="250" y="130" text-anchor="middle" fill="#b0d0c0" font-size="14">4</text>
                <circle cx="300" cy="125" r="22"/><text x="300" y="130" text-anchor="middle" fill="#b0d0c0" font-size="14">2</text>
                </g>

                <path d="M 215 40 Q 280 30 335 50" fill="none" stroke="#c9a961" stroke-width="2.5" marker-end="url(#arrowhead)"/>

                <path d="M 222 120 Q 285 110 335 90" fill="none" stroke="#c9a961" stroke-width="2.5" marker-end="url(#arrowhead)"/>

                <text x="270" y="80" text-anchor="middle" fill="#c9a961" font-size="12" font-weight="bold">${captureLabel}</text>
                </svg>`;
        }

        function renderRulesContent() {
            const t = translations[currentLang];
            const content = t.rulesContent;
            const tabs = t.rulesTabs;
            const isRu = currentLang === 'ru';

            // Update title
            document.getElementById('rulesTitle').textContent = t.rulesTitle;

            // Render tabs
            const tabsContainer = document.getElementById('rulesTabs');
            tabsContainer.innerHTML = tabs.map((tab, i) =>
                `<button class="rules-tab${i === currentRulesTab ? ' active' : ''}" onclick="switchRulesTab(${i})">${tab}</button>`
            ).join('');

            // Render content panels
            const bodyContainer = document.getElementById('rulesBody');
            let html = '';

            // Panel 0: Basics (merged with Special Moves)
            html += `<div class="rules-panel${currentRulesTab === 0 ? ' active' : ''}" data-panel="0">
                <div class="rules-section">
                    <h3 class="rules-section-title">${content.basics.intro.title}</h3>
                    <div class="rules-text"><p>${content.basics.intro.text}</p></div>
                </div>
                <div class="rules-section">
                    <h3 class="rules-section-title">${content.basics.setup.title}</h3>
                    <div class="rules-text"><p>${content.basics.setup.text}</p></div>
                    <div class="board-diagram">${getBoardDiagramSVG(isRu)}</div>
                </div>
                <div class="rules-section">
                    <h3 class="rules-section-title">${content.basics.movement.title}</h3>
                    <div class="rules-text"><p>${content.basics.movement.text}</p></div>
                    <div class="board-diagram">${getStepDiagramSVG()}</div>
                </div>
                <div class="rules-section">
                    <h3 class="rules-section-title">${content.special.extraTurn.title}</h3>
                    <div class="rules-text"><p>${content.special.extraTurn.text}</p></div>
                </div>
                <div class="rules-section">
                    <h3 class="rules-section-title">${content.special.capture.title}</h3>
                    <div class="rules-text"><p>${content.special.capture.text}</p></div>
                    <div class="board-diagram">${getCaptureDiagramSVG(isRu)}</div>
                </div>
                <div class="rules-section">
                    <h3 class="rules-section-title">${content.basics.goal.title}</h3>
                    <div class="rules-text"><p>${content.basics.goal.text}</p></div>
                </div>
            </div>`;

            // Panel 1: Super-Kalah (merged with About)
            const levels = content.superkalah.levels;
            html += `<div class="rules-panel${currentRulesTab === 1 ? ' active' : ''}" data-panel="1">
                <div class="rules-section">
                    <h3 class="rules-section-title">${content.superkalah.variant.title}</h3>
                    <div class="rules-text"><p>${content.superkalah.variant.text}</p></div>
                </div>
                <div class="rules-section">
                    <h3 class="rules-section-title">${levels.title}</h3>
                    <ul class="rules-list">
                        ${levels.list.map(l => `<li data-num="${l.num}"><strong>${l.name}</strong> ‚Äî ${l.desc}</li>`).join('')}
                    </ul>
                    <div class="rules-text"><p>${levels.text}</p></div>
                </div>
                <div class="rules-section">
                    <div class="rules-callout" style="border-left-color: #90b0a0; text-align: center;">
                        <p style="font-size: 1.1em; margin-bottom: 0;">${content.about.message}</p>
                    </div>
                </div>
                <div class="rules-author">
                    <div class="rules-author-label">${content.about.authorLabel}</div>
                    <div class="rules-author-name">${content.about.author}</div>
                </div>
            </div>`;

            bodyContainer.innerHTML = html;
        }

        function switchRulesTab(index) {
            currentRulesTab = index;
            renderRulesContent();
        }

        function showRules() {
            currentRulesTab = 0;
            renderRulesContent();
            document.getElementById('rulesModal').classList.add('show');
            document.body.style.overflow = 'hidden';
        }

        function hideRules(event) {
            if (event && event.target !== document.getElementById('rulesModal')) {
                return;
            }
            document.getElementById('rulesModal').classList.remove('show');
            document.body.style.overflow = '';
        }

        // Close modal with Escape key
        document.addEventListener('keydown', function(e) {
            if (e.key === 'Escape' && document.getElementById('rulesModal').classList.contains('show')) {
                hideRules();
            }
        });

        // Load language and start game
        loadLanguage();
        newGame();
    </script>
</body>
</html>
